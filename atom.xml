<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2021-03-18T02:54:32.110Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些流水账，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[快排的四种写法]]></title>
        <id>https://Miaite.github.io/post/M4PxdwkA_/</id>
        <link href="https://Miaite.github.io/post/M4PxdwkA_/">
        </link>
        <updated>2021-03-17T02:07:07.000Z</updated>
        <summary type="html"><![CDATA[<p>快速排序是常见的排序算法，可分为 partition 和 recursion 两个部分，至于 partition 的具体实现，有一些不同的方式可选。</p>
]]></summary>
        <content type="html"><![CDATA[<p>快速排序是常见的排序算法，可分为 partition 和 recursion 两个部分，至于 partition 的具体实现，有一些不同的方式可选。</p>
<!-- more -->
<p>本文使用 Python 且不对数据的合法性进行判断，前提要求是对一个列表类型的数组 <code>nums</code> 进行原地排序。</p>
<pre><code class="language-Python"># 先来一个最简单的
nums.sort()
</code></pre>
<h3 id="方法1填坑">方法1：填坑</h3>
<p>也就是<a href="https://book.douban.com/subject/2024655/">教材</a>上使用的方法</p>
<pre><code class="language-Python"># 不同的快排写法，区别都在于 partition
def partition(nums, l, r):
    pivot = nums[l]
    while l &lt; r:
        while l &lt; r and nums[r] &gt; pivot:
            r -= 1
        nums[l] = nums[r]
        while l &lt; r and nums[l] &lt;= pivot:
            l += 1
        nums[r] = nums[l]
    nums[l] = pivot
    return l

# 分治，递归
def q_sort(nums, l, r):
    if l &gt;= r:
        return
    pivot_idx = partition(nums, l, r)
    q_sort(nums, l, pivot_idx-1)
    q_sort(nums, pivot_idx+1, r)


def quick_sort(nums):
    q_sort(nums, 0, len(nums)-1)
</code></pre>
<h3 id="方法2交换">方法2：交换</h3>
<p>在方法1的思路上，修改为交换两个位置的元素</p>
<pre><code class="language-Python">def partition(nums, l, r):
    pivot = nums[l]
    start = l
    while l &lt; r:
        while l &lt; r and nums[r] &gt; pivot:
            r -= 1
        while l &lt; r and nums[l] &lt;= pivot:
            l += 1
        if l &lt; r:
            nums[l], nums[r] = nums[r], nums[l]
    nums[start], nums[l] = nums[l], nums[start]
    return l
</code></pre>
<h3 id="方法3区间维护">方法3：区间维护</h3>
<p>《算法导论》上面的写法：通过从左到右一次遍历，两个指针，比较并交换元素来维护区间 <code>[l, i]</code> 和 <code>(i, j)</code> 中的元素小于/大于 pivot</p>
<pre><code class="language-Python">def partition(nums, l, r):
    pivot = nums[r]
    i = l - 1
    for j in range(l, r):
        if nums[j] &lt;= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i+1], nums[r] = nums[r], nums[i+1]
    return i+1
</code></pre>
<p>其实还有一些其它的写法，不过大同小异，掌握核心思路就行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（08）]]></title>
        <id>https://Miaite.github.io/post/CvQvuRPWt/</id>
        <link href="https://Miaite.github.io/post/CvQvuRPWt/">
        </link>
        <updated>2020-11-19T08:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 49~55。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 49~55。</p>
<!-- more -->
<h2 id="term-49了解-new-handler-的行为">Term 49：了解 new-handler 的行为</h2>
<p>当 operator new 无法满足内存分配需求时，会抛出异常，且在此之前，会先调用用户设置的错误处理函数（即 new-handler）。通过 <code>std::set_new_handler</code> 可以设置 new-handler，要使其设计良好，需要满足以下条件：</p>
<ol>
<li>让更多内存可被使用</li>
<li>安装另一个 new-handler：设置调用另一个可能解决问题的 new-handler</li>
<li>卸除 new-handler：将 null 指针传给 set_new_handler。没有安装 new-handler 时 operator new 分配失败抛出异常</li>
<li>不返回：通常调用 abort 或 exit</li>
</ol>
<p>C++ 没有直接为 class 定制 new-handler 的语法，但我们仍然可以办到：</p>
<pre><code>template &lt;typename T&gt;
class NewHandlerSupport {  // mixin 风格的 base class，用以支持 class 专属的 set_new_handler
 public:
  static std::new_handler set_new_handler(std::new_handler) throw();
  static void* operator new(std::size_t size) throw(std::bad_alloc);

 private:
  static std::new_handler currentHandler;
};
template &lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw() {
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}
template &lt;typename T&gt;
void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc) {
  NewHandlerSupport h(std::set_new_handler(currentHandler));
  return ::operator new(size);
}
template &lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;  // 将 currentHandler 初始化为 null
// 使用方式如下
class Widget: public NewHandlerSupport&lt;Widget&gt; { ... } // 以自身类型继承这样一个模板类就足够
</code></pre>
<h2 id="term-50了解-new-和-delete-的合理替换时机">Term 50：了解 new 和 delete 的合理替换时机</h2>
<p>使用自定义的 operator new 和 operator delete 的合理使用场景：</p>
<ol>
<li>用来检测运用错误</li>
<li>收集动态分配内存的统计数据</li>
<li>增加分配和归还的速度</li>
<li>降低默认内存管理器带来的额外开销</li>
<li>实现内存地址对齐（alignment）</li>
<li>将相关的对象成簇集中，降低缺页中断的概率，因为它们很可能同时被调用</li>
<li>实现一些特定行为，例如在归还内存时将内容抹除</li>
</ol>
<h2 id="term-51编写-new-和-delete-时需固守常规">Term 51：编写 new 和 delete 时需固守常规</h2>
<p>operator new 分配成功时返回指针，不成功则调用 new-handler，可能会再尝试分配，所有的 new-handler 失败，则抛出 bad_alloc 异常。在设计自定义的 operator new 和 operator delete 过程中，需要注意：</p>
<ol>
<li>即使请求的是 0 byte， operator new 也要返回一个合法的指针，则可以简单地将 0 视为 1</li>
<li>operator new 应该内含无穷循环来实现上面那段话</li>
<li>class 专属版本的 operator new 应该处理错误大小的分配请求，比如被派生类继承之后，对派生类使用（基类的） new 会造成大小错误</li>
<li>operator delete 应该在收到 null 指针时不做任何事</li>
<li>class 专属版本的 operator delete 应该处理错误大小的分配请求</li>
</ol>
<h2 id="term-52写了-placement-new-也要写-placement-delete">Term 52：写了 placement new 也要写 placement delete</h2>
<ol>
<li>编写了 placement new 也要写 placement delete，否则可能会造成内存泄漏</li>
<li>声明  placement new 和 placement delete 时，要注意不要遮蔽了它们的正常版本</li>
</ol>
<h2 id="term-53不要轻忽编译器的警告">Term 53：不要轻忽编译器的警告</h2>
<ol>
<li>认真考虑编译器的警告</li>
<li>不同编译器针对相同代码的警告处理可能不一样</li>
</ol>
<h2 id="term-54让自己熟悉包括-tr1-在内的标准程序库">Term 54：让自己熟悉包括 TR1 在内的标准程序库</h2>
<p>如题。</p>
<h2 id="term-55让自己熟悉-boost">Term 55：让自己熟悉 Boost</h2>
<p>在 Modern C++ 的时代，Boost 的应用意义已经不如从前。但在熟悉标准程序库之后，Boost 仍是很好的学习对象，它包含了可能在未来会纳入标准程序库的一些东西。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（07）]]></title>
        <id>https://Miaite.github.io/post/sF-ehhx1o/</id>
        <link href="https://Miaite.github.io/post/sF-ehhx1o/">
        </link>
        <updated>2020-11-17T12:33:03.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 41~48。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 41~48。</p>
<!-- more -->
<h2 id="term-41了解隐式接口和编译期多态">Term 41：了解隐式接口和编译期多态</h2>
<ol>
<li>classes 和 templates 都支持接口和多态</li>
<li>对 classes 而言接口时显式的，以函数签名（函数名、参数类型、返回类型）为中心。多态则通过 virtual 函数发生与运行期</li>
<li>对 templates 参数而言，接口是隐式的，基于有效表达式。多态则是通过 template 具现化和函数重载解析发生与编译期</li>
</ol>
<h2 id="term-42了解-typename-的双重意义">Term 42：了解 typename 的双重意义</h2>
<ol>
<li>声明 template 参数时，前缀关键字 class 和 typename 同义</li>
<li>需要使用关键字 typename 标识嵌套从属类型名称；但不得在 base class lists（基类列）或 member initialization list 内以它作为 base class 修饰符</li>
</ol>
<pre><code>template &lt;typename C&gt;               // 可以使用 typename 或者 class
void f(const C&amp; container,          // 不能使用 typename
       typename C::iterator iter);  // 应该使用 typename

template &lt;typename T&gt;
class Drived : public Base&lt;T&gt;::Nested {  // 不使用 typename
 public:
  explicit Derived(int x) : Base&lt;T&gt;::Nested(x) {  // 不使用 typename
    typename Base&lt;T&gt;::Nested tmp;                 // 使用 typename
  }
};
</code></pre>
<h2 id="term-43学习处理模板化基类内的名称">Term 43：学习处理模板化基类内的名称</h2>
<p>派生类继承模板化基类的情况中，如果直接调用基类中的成员，会无法通过编译，因为编译器<strong>无法知道具体继承自哪个基类</strong>（假如基类被特化，可能根本不包含被调用的成员）。为了解决这个问题，有3种方法：</p>
<ol>
<li>使用 <code>this-&gt;</code></li>
<li>使用 <code>using</code></li>
<li>明确指明使用 base class 版本（不推荐，相当于关闭了 virtual）</li>
</ol>
<pre><code>template &lt;typename Company&gt;
class LoggingMsgSender: public MsgSender&lt;Company&gt; {  // MsgSender 中包含 sendClear() 函数
 public:
  using MsgSender&lt;Company&gt;::sendClear;  // 2.方法
  void sendClearMsg(const MsgInfo&amp; info) {
    sendClear(info);                      // 调用失败
    this-&gt;sendClear(info);                // 1.方法
    MsgSender&lt;Company&gt;::sendClear(info);  // 3.方法
  }
};
</code></pre>
<h2 id="term-44将与参数无关的代码抽离-template">Term 44：将与参数无关的代码抽离 template</h2>
<ol>
<li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可<strong>消除</strong>，做法是以函数参数或 class 成员变量替换 template 参数</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可<strong>降低</strong>，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码</li>
</ol>
<h2 id="term-45运用成员函数模板接受所有兼容类型">Term 45：运用成员函数模板接受所有兼容类型</h2>
<p>智能指针是很好用的东西，但是存在一个问题，其模板写法不能支持隐式的类型转换。真实的指针则可以做到，示例就是派生类指针可以隐式转换为基类指针。为了在使用智能指针时也能达到此效果，需要这样编写程序：</p>
<pre><code>template &lt;typename T&gt;
class SmartPtr {
 public:
  template &lt;typename U&gt;
  SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPrt(other.get()) { /*...*/ } // 支持隐式转换的 copy 构造函数模板
  T* get() const { return heldPtr; }  // 假设通用接口 get() 获取原始指针

 private:
  T* heldPtr;  // 原始指针
};
</code></pre>
<p>跟上面的操作一样，copy 赋值操作符也可以进行泛化。需注意，函数模板不会覆盖编译器自动生成的 copy 构造函数和copy 赋值操作符。</p>
<h2 id="term-46需要类型转换时请为模板定义非成员函数">Term 46：需要类型转换时请为模板定义非成员函数</h2>
<p>Term 24 提到应使用 non-member 函数对所有实参进行类型转换。在使用模板时，情况有一点变化，我们仍然应该编写一个 non-member 函数，然后再 class 中定义 friend 函数并调用外面的 non-member 函数。</p>
<pre><code>template &lt;typename T&gt; class Rational; // 声明类
template &lt;typename T&gt;
const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs); // 声明 helper

template &lt;typename T&gt;
class Rational {
 public:
  friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) { // 调用 helper
    return doMultiply(lhs, rhs);
  }
};

template &lt;typename T&gt;
const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) { ... } // 定义 helper
</code></pre>
<h2 id="term-47请使用-traits-classes-表现类型信息">Term 47：请使用 traits classes 表现类型信息</h2>
<ol>
<li>Traits classes 使得“类型相关信息”在编译器可用。它们以 templates 技术、typedef 表示类型和 “templates 特化”完成实现</li>
<li>Traits classes 通过重载，在编译器对类型执行 if...else 测试</li>
</ol>
<h2 id="term-48认识-template-元编程">Term 48：认识 template 元编程</h2>
<p>Template 元编程（TMP）是执行与编译器的过程，通过 template 产生更多源码。TMP 的贡献在于，将一些运行期的工作带到了编译期执行，通常会产生出更加高效的程序，并且在编译期就发现一些问题。TMP 单独来说已经是图灵完全机器，但是编写 TMP 代码会比“一般”C++ 难得多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（06）]]></title>
        <id>https://Miaite.github.io/post/N2VZ5x8wW/</id>
        <link href="https://Miaite.github.io/post/N2VZ5x8wW/">
        </link>
        <updated>2020-11-15T07:39:08.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
<!-- more -->
<h2 id="term-32确定你的-public-继承塑模出-is-a-关系">Term 32：确定你的 public 继承塑模出 is-a 关系</h2>
<p>public 继承意味着 is-a 关系。适用于 base classes 的每一件事情同样适用于 derived classes。</p>
<h2 id="term-33避免遮掩继承而来的名称">Term 33：避免遮掩继承而来的名称</h2>
<p>和局部/全局作用域类似，派生类/基类的成员也有这样的作用域覆盖关系。</p>
<ol>
<li>derived classes 内的名称会遮掩 base classes 内的名称（包括参数类型不同的函数）。在 public 继承下不应如此。</li>
<li>可以使用 <code>using</code> 声明式或者转交函数让被遮掩的名称恢复</li>
</ol>
<pre><code>class Base {
 public:
  virtual void mf1() = 0;
  virtual void mf1(int);
  void mf2();
  void mf2(double);
  ......
};
class Derived : public Base {
 public:
  using Base::mf1;  // 让 Base::mf1 可见
  virtual void mf1();
  void mf2() { Base::mf2(); };  // 实际调用了 Base::mf2()
  ......
};
......
Derived d;
int x;
double y;
d.mf1();   // 调用 Derived::mf1()
d.mf1(x);  // 调用 Base::mf1(int)
d.mf2();   // 调用了 Derived::mf2()，内部实际调用了 Base::mf2()
d.mf2(y);  // 不可行，被遮蔽
</code></pre>
<h2 id="term-34区分接口继承和实现继承">Term 34：区分接口继承和实现继承</h2>
<ol>
<li>接口继承和实现继承是不同的，在 public 继承下，derived classes 总是继承 base classes 的接口</li>
<li>pure virtual 函数继承接口</li>
<li>impure virtual 函数继承接口和缺省实现</li>
<li>non-virtual 函数继承接口和强制实现，不应该在 derived classes 中 override</li>
</ol>
<h2 id="term-35考虑-virtual-函数以外的其它选择">Term 35：考虑 virtual 函数以外的其它选择</h2>
<p>利用 virtual 函数去实现某些功能可能并非最佳选择，可以考虑一些其它的办法：</p>
<ol>
<li>使用 non-virtual interface(NVI) 手法，以 public non-virtual 成员函数包裹访问性较低的（private） virtual 函数，这是 <strong>Template Method</strong> 设计模式的一种特殊形式</li>
<li>将 virtual 函数替换为“函数指针成员变量”，这是 <strong>Stratege</strong> 设计模式的一种分解形式</li>
<li>进一步，将 2. 中的函数指针替换为 <code>tr1::function</code>，则只要能兼容相应的参数的可调用对象都可以被应用上</li>
<li>对于 3. 中的可调用对象，可以以（继承的）类去实现，相当于抽取出 virtual 函数的功能，在另一个类中实现</li>
<li>2./3./4. 带来的缺点是，无法访问 non-public 成员</li>
</ol>
<h2 id="term-36绝不重新定义继承而来的-non-virtual-函数">Term 36：绝不重新定义继承而来的 non-virtual 函数</h2>
<p>这样会造成一些混乱，比如，以一个基类指针指向派生类对象时，调用的 non-virtual 函数会是基类的版本。原因在于静态绑定。</p>
<h2 id="term-37绝不重新定义继承而来的缺省参数值">Term 37：绝不重新定义继承而来的缺省参数值</h2>
<p>不要重新定义继承而来的缺省参数值，它是静态绑定，而 virtual 函数是动态绑定。</p>
<h2 id="term-38通过复合塑模出-has-a-或者根据某物实现出">Term 38：通过复合塑模出 has-a 或者“根据某物实现出”</h2>
<p>对于 has-a 或者“根据某物实现出”的情况，需要做的不是继承，而是在自己编写的类中使用需要用到的类的对象。</p>
<h2 id="term-39明智而审慎地使用-private-继承">Term 39：明智而审慎地使用 private 继承</h2>
<ol>
<li>private 继承意味着“根据某物实现出”这种情况，它通常比复合级别低，在需要访问 protect成员或者需要 override virtual 函数时，这样的设计时合理的</li>
<li>private 继承在大多数编译器中可以实现 empty base optimization，这对空间敏感的开发任务有效</li>
</ol>
<h2 id="term-40明智而审慎地使用多重继承">Term 40：明智而审慎地使用多重继承</h2>
<ol>
<li>多重继承可能导致歧义性，以及对 virtual 继承的需要</li>
<li>virtual 继承会增加各方面成本，最佳情况时不带任何数据</li>
<li>多重继承在某些情况确实有用，比如 public 继承一个接口 class，同时 private 继承一个实现 class</li>
<li>尽量不要使用多重继承</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（05）]]></title>
        <id>https://Miaite.github.io/post/Lxmd6dG5E/</id>
        <link href="https://Miaite.github.io/post/Lxmd6dG5E/">
        </link>
        <updated>2020-11-11T11:48:56.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
<!-- more -->
<h2 id="term-26尽可能延后变量定义式出现时间">Term 26：尽可能延后变量定义式出现时间</h2>
<p>定义一个变量（或者对象）对调用其构造函数，因此最好时在需要的时刻才去定义并初始化。至于只在循环内使用的变量通常定义在<strong>循环内</strong>，除非明确知道赋值比构造+析构更加高效而且确实有必要时，才将其定义在循环外。</p>
<h2 id="term-27尽量少做转型动作">Term 27：尽量少做转型动作</h2>
<ol>
<li>如果可以，尽量避免转型，特别是避免低效的 dynamic_casts，优先尝试其它的解决方案</li>
<li>如果转型是必要的，试着将它隐藏与函数之中</li>
<li>不要使用 C 风格的转型</li>
</ol>
<h2 id="term-28避免返回-handles-指向对象内部成分">Term 28：避免返回 handles 指向对象内部成分</h2>
<p>避免返回 handles（包括指针、引用、迭代器）指向对象内部成分。这样可以增加封装性，并且避免 handle 在对象被销毁后指向空。</p>
<h2 id="term-29为异常安全而努力是值得的">Term 29：为“异常安全”而努力是值得的</h2>
<ol>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏</li>
<li>异常安全函数三种保证：基本型（保证程序有效）、强烈型（保证程序回到之前的状态）、不抛异常型</li>
<li>强烈保证往往能够以 copy-and-swap 实现出来，但强烈保证并非对所有函数都可以实现或具备现实意义</li>
<li>函数提供的异常安全保证通常等于其所调用的函数中异常安全保证最弱的那个（木桶效应）</li>
</ol>
<h2 id="term-30透彻了解-inlining-的里里外外">Term 30：透彻了解 inlining 的里里外外</h2>
<p>inline 是编译器可选的操作，实际取决于具体编译器的平台和版本等。</p>
<ol>
<li>定义于 class 内的函数是一种隐式 inline 请求</li>
<li>inline 应当用于小型的、调用频繁的函数，避免代码膨胀，使调试和程序升级的过程也变得更加容易</li>
</ol>
<h2 id="term-31将文件间的编译依存关系降至最低">Term 31：将文件间的编译依存关系降至最低</h2>
<p>降低文件间的编译依存关系有助于减少编译的工作量</p>
<ol>
<li>支持“编译依存性最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（04）]]></title>
        <id>https://Miaite.github.io/post/gbhU7f2k5/</id>
        <link href="https://Miaite.github.io/post/gbhU7f2k5/">
        </link>
        <updated>2020-11-10T06:29:15.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
<!-- more -->
<h2 id="term-18让接口容易被正确使用不易被误用">Term 18：让接口容易被正确使用，不易被误用</h2>
<p>这一点其实比较难做到，可以参考这几个方面：</p>
<ol>
<li>接口的一致性，与内置类型（包括 STL）的行为兼容</li>
<li>防止误用包括建立新类型、限制类型上的操作、束缚对象的值以及自动管理资源</li>
<li>shared_ptr 支持定制型 deleter，可以防范 DLL 问题，可用来自动解除互斥锁</li>
</ol>
<h2 id="term-19设计-class-犹如设计-type">Term 19：设计 class 犹如设计 type</h2>
<p>在 C++ 中，设计一个通用的 class 就是设计一个新的类型，需要考虑以下一些方面：</p>
<ol>
<li>新 type 的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？调用不同的函数</li>
<li>新 type 的对象如果被 passed by value，意味着什么？会调用 copy 构造函数</li>
<li>什么是新 type 的合法值？</li>
<li>你的新 type 需要配合某个继承图系吗？继承自某个 class 或者允许被继承有不同的设计要点</li>
<li>你的新 type 需要什么样的转换？考虑是否需要在不同的 class 对象之间转换，设计显式/隐式转换</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？禁用编译器自动生成的函数</li>
<li>谁该取用新 type 的成员？考虑如何设置 public/protect/private 成员以及 friends</li>
<li>什么是新 type 的 undeclared interface？</li>
<li>你的新 type 有多么一般化？考虑定义一个新的 class template</li>
<li>你真的需要一个新 type 吗？也许通过多个函数或者 template 就能达到需要</li>
</ol>
<h2 id="term-20宁以-pass-by-reference-const-替换-pass-by-value">Term 20：宁以 pass-by-reference-const 替换 pass-by-value</h2>
<p>C++ 默认以 value 形式进行传递，这会带来大量的复制消耗，而且可能造成对象切割（slicing）问题。以 reference 传递会高效很多。但也有例外，内置类型、STL 迭代器以及函数对象以 value 传递更加合适。</p>
<h2 id="term-21必须返回对象时别妄想返回器-reference">Term 21：必须返回对象时，别妄想返回器 reference</h2>
<p>返回 pointer/reference 指向 local 对象是错误行为，指向 local static 也是愚蠢的行为（但可行），reference 指向 heap-allocated 对象会内存泄漏。</p>
<h2 id="term-22将成员变量声明为-private">Term 22：将成员变量声明为 private</h2>
<p>简单来说，就是为了提高 class 的封装性</p>
<h2 id="term-23宁以-non-menber-non-friend-替换-member-函数">Term 23：宁以 non-menber、non-friend 替换 member 函数</h2>
<p>这样既可以增加 class 的封装性，也可以让函数更容易扩充。</p>
<h2 id="term-24若所有参数皆需类型转换请为此采用-non-menber-函数">Term 24：若所有参数皆需类型转换，请为此采用 non-menber 函数</h2>
<p>采用 non-menber 函数可以进行合适的隐式类型转换。</p>
<h2 id="term-25考虑写出一个不抛出异常的-swap-函数">Term 25：考虑写出一个不抛出异常的 swap 函数</h2>
<p>STL 中默认的 swap 函数会调用 copy 构造函数和 copy 赋值运算符，在某些情况下带来不必要的性能损耗。可以考虑的改写思路：</p>
<ol>
<li>添加一个用于 swap 的 public member 函数（不能抛出异常）</li>
<li>在 class 或者 template 的命名空间提供一个 non-member 函数 swap，用这个函数调用 1. 中的 member 函数 swap。这点可适用于 class template</li>
<li>特化 std::swap 来调用 member 函数 swap</li>
<li>用户使用 swap 时应当使用 <code>using std::swap;</code></li>
</ol>
<pre><code>template&lt;typename T&gt;
void doSomething(T&amp; obj1, T&amp; obj2){
    using std::swap;    // 让 std::swap 在此函数内可见
    swap(obj1, obj2);    // 自动选择最佳的 swap 版本
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/386I6Xacv/</id>
        <link href="https://Miaite.github.io/post/386I6Xacv/">
        </link>
        <updated>2020-11-07T07:42:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
<!-- more -->
<h2 id="term-13以对象管理资源">Term 13：以对象管理资源</h2>
<p>编写 C++ 程序容易遇到的一个问题就是内存泄漏，手动 <code>delete</code> 容易遇到各种问题。一个较好的解决方案是使用类来管理资源，通过析构过程保证资源的正确释放。</p>
<ol>
<li>使用 RAII 对象，在其构造函数中获取资源，析构函数中释放资源</li>
<li>常用的 RAII 对象，智能指针，shared_ptr 和 unique_ptr</li>
</ol>
<h2 id="term-14在资源管理类中小心-copying-行为">Term 14：在资源管理类中小心 copying 行为</h2>
<p>可选的策略有：</p>
<ol>
<li>禁止复制</li>
<li>引用计数</li>
<li>深拷贝</li>
<li>转移所有权（auto_ptr 那样的行为）</li>
</ol>
<h2 id="term-15在资源管理类中提供对原始资源的访问">Term 15：在资源管理类中提供对原始资源的访问</h2>
<p>RAII class 应当提供一个直接获取到原始资源（指针/引用）的方法。一般来说，显示转换比较安全，隐式转换比较方便。</p>
<h2 id="term-16成对使用-new-和-delete-时要采取相同形式">Term 16：成对使用 new 和 delete 时要采取相同形式</h2>
<p>如果在 <code>new</code> 时使用了 <code>[]</code>，那么在 <code>delete</code> 时也应使用 <code>[]</code>，未使用 <code>[]</code> 时同样要准寻这个原则，以避免释放资源出错。</p>
<h2 id="term-17以独立语句将-newed-对象置入智能指针">Term 17：以独立语句将 newed 对象置入智能指针</h2>
<p>要以独立语句将 newed 对象置入智能指针，否则可能发生难以察觉的资源泄漏</p>
<pre><code>// 首先有以下定义
int priority();
void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);
// 几种调用
processWidget(new Widget, priority());    // 出错，shared_ptr 无法隐式转换
processWidget(std::tr1::shared_ptr&lt;Widget&gt; (new Widget), priority());    // 虽然可以通过编译，但是假如 priority() 先于 shared_ptr 的构造函数执行且出现异常，则资源泄漏
// 下面时正确做法
std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);
processWidget(pw, priority());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（02）]]></title>
        <id>https://Miaite.github.io/post/ol7D4iZKg/</id>
        <link href="https://Miaite.github.io/post/ol7D4iZKg/">
        </link>
        <updated>2020-11-05T11:45:07.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
<!-- more -->
<h2 id="term-05了解-c-默默编写并调用了哪些函数">Term 05：了解 C++ 默默编写并调用了哪些函数</h2>
<p>编译器会为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符以及析构函数，它们都是 public 以及 inline 的。注意到，当 copy assignment 操作符在父类中被声明为 private 或者含有 const 成员面对等情况，编译器不会自动创建 copy assignment 操作符；编译器自动创建的析构函数不是虚函数，除非继承自虚函数。</p>
<h2 id="term-06若不想使用编译器自动生成的函数就应该明确拒绝">Term 06：若不想使用编译器自动生成的函数，就应该明确拒绝</h2>
<p>通过 Term 05 我们知道编译器会自动生成一些成员函数，但有时我们可能不需要这种功能。解决方法：</p>
<ol>
<li>将该成员函数声明为 private 并且不予实现</li>
<li>按照 1. 构建一个基类，然后去继承它</li>
<li>使用 C++(11) 提供的 <code>=default</code> 和 <code>=delete</code> 显式启用或者禁用编译器自动版本的函数</li>
</ol>
<h2 id="term-07为多态基类声明-virtual-析构函数">Term 07：为多态基类声明 virtual 析构函数</h2>
<ol>
<li>用作多态的基类应该声明 virtual 析构函数。如果 class 带有 virtual 成员函数，应该声明 virtual 析构函数</li>
<li>不是基类或者不是用作多态的基类，不应该声明 virtual 析构函数，比如 STL 容器</li>
<li>以上两点可以避免内存泄漏</li>
</ol>
<h2 id="term-08别让异常逃离析构函数">Term 08：别让异常逃离析构函数</h2>
<p>不应该在析构函数内抛出异常，保证析构函数能执行。将可能造成异常的部分移到另一个函数内或者交给用户自己处理。在 C++(11) 中，可以使用 <code>noexcept</code> 来限制函数，如果出现异常会直接终止程序。</p>
<h2 id="term-09绝不在构造和析构过程中调用-virtual-函数">Term 09：绝不在构造和析构过程中调用 virtual 函数</h2>
<p>如果在 base class 构造和析构过程中调用 virtual 函数，该函数的版本是 base class 对应的版本，不会是意图的 derived class 版本。</p>
<h2 id="term-10令-operator-返回一个-reference-to-this">Term 10：令 operator= 返回一个 reference to *this</h2>
<p>可以实现右结合的连锁赋值，大家都这么做，一种习惯性接口。</p>
<h2 id="term-11在-operator-中处理自我赋值">Term 11：在 operator= 中处理“自我赋值”</h2>
<ol>
<li>如果将一个对象赋值给自身，会造成安全问题。处理方法可以是：通过地址判断是否是同一对象；安排安全的语句顺序；copy-and-swap</li>
<li>任何函数，如果操作多个对象，要考虑其中某些对象其实是同一个这种情况</li>
</ol>
<h2 id="term-12复制对象时勿忘每一个成分">Term 12：复制对象时勿忘每一个成分</h2>
<ol>
<li>copy 构造函数和 copy 赋值操作符会执行拷贝</li>
<li>拷贝对象时应该把每个成员变量都考虑到，并且调用对应的 base class 的函数</li>
<li>copy 构造函数和 copy 赋值操作符之间<strong>不能</strong>互相调用，可以考虑新创建一个成员函数维护冗余代码，然后在 copy 操作时调用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（01）]]></title>
        <id>https://Miaite.github.io/post/UyR9S6D5b/</id>
        <link href="https://Miaite.github.io/post/UyR9S6D5b/">
        </link>
        <updated>2020-11-03T11:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
]]></summary>
        <content type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
<!-- more -->
<h2 id="term-01视-c-为一个语言联邦">Term 01：视 C++ 为一个语言联邦</h2>
<p>这一点说起来容易（做起来难）。简单讲，C++ 的语言设计其实有四个部分 ：（兼容）C、面向对象、泛型和模板、STL，这四个部分相互关联却又在设计思想上相对独立。每一个部分都会有一些不同的准则，在 C 中的常用思路不一定适合在泛型和模板中使用。</p>
<p>一般来说，泛型和模板这一部分是 C++ 程序员最薄弱的，需要特别注意。</p>
<h2 id="term-02尽量以-const-enum-inline-替换-define">Term 02：尽量以 const, enum, inline 替换 #define</h2>
<ol>
<li>对于常量，使用 const 或者 enum hack 代替</li>
<li>对于形似函数的宏定义，使用 inline 函数代替（可能会用到模板）</li>
</ol>
<pre><code>// enum hack 的例子：
class Game {
    private:
        static const int GameTurn = 10;
        int scores[GameTurn];
};    //不支持类内初始化的编译器报错
class GamePlayer{
    private:
        enum {NumTurns = 5};
        int scores[NumTurns];
};    //不支持类内初始化的编译器也能编译通过
</code></pre>
<h2 id="term-03尽可能使用-const">Term 03：尽可能使用 const</h2>
<ol>
<li>const 和指针：记住 <code>const</code> 出现在 <code>*</code> 左边，表示被指物是常量；如果出现在 <code>*</code> 右边，表示指针自身是常量；如果出现在 <code>*</code> 两边，表示被指物和指针都是常量</li>
<li>STL 的迭代器可以视为指针，<code>const std::vector&lt;int&gt;::iterator iter</code> 效果等同于 <code>T* const</code>，<code>std::vector&lt;int&gt;::const_iterator cIter</code> 效果等同于 <code>const T*</code></li>
<li>设置函数返回对象为 const 可以排除一些不必要的安全隐患</li>
<li>类的成员函数可以通过（函数名之后，函数体之前的那个） <code>const</code> 重载，分别针对 const/non-const 对象</li>
<li>bitwise const 和 logical const 的区别，通过 <code>mutable</code> 实现 logical const</li>
<li>当成员函数的 const/non-const 版本有同样的实现时，可以将实现代码写在 const 版本中，而在 non-const 版本中调用即可，但是需要注意<strong>转换类型</strong>，并且一定要小心，避免安全隐患。</li>
</ol>
<pre><code>class TextBlock {
 public:
  const char&amp; operator[](std::size_t position) const { return text[position]; }
  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);
  }
  // ......
};
</code></pre>
<h2 id="term-04确定对象被使用前已被初始化">Term 04：确定对象被使用前已被初始化</h2>
<ol>
<li>手动初始化内置型对象，比如 <code>int i = 0;</code></li>
<li>构造函数使用成员初值表进行初始化</li>
<li>为免除“跨编译单元初始化顺序不确定”问题，使用 local static 对象替换 static 对象</li>
</ol>
]]></content>
    </entry>
</feed>