<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2021-12-23T03:25:42.007Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些流水账，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[2021 后端开发秋招总结]]></title>
        <id>https://Miaite.github.io/post/k0VH9clEu/</id>
        <link href="https://Miaite.github.io/post/k0VH9clEu/">
        </link>
        <updated>2021-12-23T02:41:54.000Z</updated>
        <summary type="html"><![CDATA[<p>菜鸡的秋招之路。</p>
]]></summary>
        <content type="html"><![CDATA[<p>菜鸡的秋招之路。</p>
<!-- more -->
<h1 id="个人背景">个人背景</h1>
<p>末流 211 GIS 本，末流 985 CS 硕，在实验室做的课题是图像处理/深度学习。导师放养，但是不让实习，研二的时候论文还没进展，就放弃学术准备就业了。AI 算法岗肯定是不行的，没有好 paper，就打算做后端开发了，把 C++ 重新捡了起来，并且速成了一下 Go（因为个人不喜欢 Java，不然直接 Java 一把梭也不错）。地点是倾向于成都，但是大厂根本没机会，都是直接转到其他地方的部门面试，只有美团面了一次成都的岗。</p>
<h1 id="前期准备">前期准备</h1>
<p>导师说了不放实习，一开始也没准备春招找暑期实习。3月的时候，室友 X 开始准备暑期实习，并推荐我先准备准备不能去再说，就赶鸭子上架投了两三家大厂，面了四五场，然后被暴打（这里其实有个坑，后面再说）。</p>
<p>意识到自己的菜鸡本质之后，就安心抽时间准备秋招了。大体上就三个方面：1）刷题，剑指 offer + leetcode Top100 + <a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/">力扣加加</a> 顺着顺序刷了一些，再加上少许 SQL 题，总计 300 上下。我刷题能力不强，准备到这个程度，应付常规的题问题不大。2）八股，计算机网络，操作系统，数据库（主要是 MySQL 知识点），编程语言基础，Linux 系统编程等等。3）项目经验，我找了两个别人的开源项目，自己写了一遍，有些地方稍微改进了一下，不改也问题不大，但是要把里面涉及到的东西理解到位，面试肯定会重点问。在实验室的课题也会被问道，主要是看表达和思路，毕竟面试官基本不懂这方面的细节。</p>
<p>我的简历很普通，没有实习，没有相关领域论文，没有有含金量的奖项，导致后面很多厂直接不给面试机会😥。还好学历还算过关，笔试一般也能过关，大厂还能给个机会。</p>
<p>差不多 6 月逐渐开始投简历，陆续做笔试，8月中旬开始面试，9 月收了两个满意的意向书就躺了。</p>
<h1 id="提前批及秋招投递情况">提前批及秋招投递情况</h1>
<p>总共投了有 40 家的样子，互联网大小厂，国企，金融，外企等等都有</p>
<h2 id="简历挂笔试挂一直没消息的">简历挂/笔试挂/一直没消息的</h2>
<p>TP-LINK、京东、米哈游、百度、爱奇艺、海康威视、Shein、搜狐、旷视、陌陌、网易互娱、网易雷火、网易互联网、SmartX、Zoom（让我申请转客户端）、知乎、哔哩哔哩、贝壳、快手、酷家乐、FreeWheel、Paypal</p>
<p>点名批评 Shein、米哈游、哔哩哔哩，笔试全 A 然后挂</p>
<h2 id="有意向书之后放弃笔试面试的">有意向书之后放弃笔试/面试的</h2>
<p>触宝、OPPP、小米、新浪、电信天翼云、龙湖、莉莉丝、腾讯音乐、农行、搜狐（11月才约面试）</p>
<h2 id="面试挂了的">面试挂了的</h2>
<p>华为、携程、美团、东方财富、腾讯、Garena</p>
<h2 id="拿到-offer-的">拿到 offer 的</h2>
<p>招银网络科技、字节跳动、阿里巴巴、Shopee</p>
<h3 id="招银网络科技">招银网络科技</h3>
<h4 id="成都后端开发">成都后端开发</h4>
<p>这家的提前批开始得非常早，6 月初面完了，6 月底发意向，9 月底开奖，10 月初逼签，面试不难，问题比较常规。</p>
<h3 id="东方财富">东方财富</h3>
<p>一面是 HR 面，然后挂了😅</p>
<h3 id="携程">携程</h3>
<h4 id="一面挂">一面挂</h4>
<p>云计算平台的岗，先讲了实验室的课题，然后做了个最长回文子串，我写的动态规划方法，面试官不满意，说要中心扩展，我提了一下 Manacher 算法（但是不会写），另外随便问了点其它的东西，就结束了。</p>
<h3 id="美团">美团</h3>
<h4 id="一面挂-2">一面挂</h4>
<p>问得不难，比较常规，基本都答上来了，感觉面试官只会 Java，我不会 Java 他有点不知道问什么。</p>
<h4 id="被捞再次一面挂">被捞再次一面挂</h4>
<p>乱起八糟的问了很多，不记得了，有些没答不上。</p>
<h4 id="后面又捞了两次">后面又捞了两次</h4>
<p>都拒了，不想面了，总结就是：不会 Java 面美团会比较难受</p>
<h3 id="腾讯">腾讯</h3>
<h4 id="csig-一面挂">CSIG 一面挂</h4>
<p>问了不少很虚的技术问题，不知道怎么回答是好，比如 “C++ 有哪些泛化的方法？”</p>
<h4 id="teg-三面挂">TEG 三面挂</h4>
<p>一二面比较常规，八股+项目+做题，有些八股会问得比较深。三面问了一个 C++ 的隐式类型转化，答错了，后面一个场景设计题也不太答得上来，就挂了。</p>
<h3 id="华为">华为</h3>
<h4 id="成研所光产品主管面挂">成研所光产品，主管面挂</h4>
<p>一二面也算常规，难度比 TEG 小，但是二面做题没做出来。主管面比较玄学，主要是性格方面的。总的来说华为性格测试很恶心。</p>
<h3 id="字节跳动">字节跳动</h3>
<p>杭州基础架构，offer</p>
<h4 id="一面">一面</h4>
<p>除了常规之外，B+树/B树/AVL/红黑树问得比较深，主要 是 MySQL 索引一起提到的，做题是 <a href="https://leetcode-cn.com/problems/reorder-list/">leetcode143</a>，我当时以为牛客网上就是白板不能运行，结果写出来有 bug…</p>
<h4 id="二面">二面</h4>
<p>进程、线程、内核态那一块问得比较深，问到不会为止，用户态程序是不能看到内核空间还是禁止访问内核空间。做题是求逆序对数，没写出来…</p>
<h4 id="三面">三面</h4>
<p>项目问得多一些，细节延申，做题是 <a href="https://leetcode-cn.com/problems/merge-intervals/">leetcode56</a>。</p>
<p>之前暑期实习就面了字节，然后挂了，而且面评不好，导致秋招有点难捞。提前批一开始投了成都抖音，简历秒挂，找 HR 朋友转推了成都飞书，还是简历挂。隔了大半个月吧，被杭州基础架构捞了，幸运上岸，拿了第一个大厂意向书。</p>
<h3 id="阿里巴巴">阿里巴巴</h3>
<p>杭州阿里云，offer</p>
<h4 id="一面-2">一面</h4>
<p>电话面，压力很大，问得东西比较深入，比较难，不太偏八股，比较灵活，从简历上项目入手逐步引导深入。</p>
<h4 id="二面-2">二面</h4>
<p>电话面，和一面类似，但是轻松一些。场景算法题：数据流求中位数/最大值，求出现频率最高的 topK，前几个问题的分布式版本这套组合拳。</p>
<h4 id="三面-2">三面</h4>
<p>视频面，问题比较轻松常规，C++ 八股，写了个题，抽象接口设计题，有点难（以前没写过这种）。</p>
<p>总的来说，这是面试体验最好的一家，面试官技术水平和面试水平都很高，风格和其他家也不一样，整体有种技术宅的氛围。</p>
<h3 id="shopee">Shopee</h3>
<p>深圳，部门未定，流程比较晚没有意向书直接发了 offer</p>
<h4 id="深圳93-一面1012-二面都要泡化了">深圳，9.3 一面，10.12 二面，都要泡化了</h4>
<p>面试体验很好，外企面试规范那种，感觉很尊重人，一面最后问了面试官，他说我简历没啥亮点，但是面下来感觉还挺好的。做题是 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">leetcode124</a> 和 <a href="https://leetcode-cn.com/problems/min-stack/">leetcode155</a>。其他一个是常规八股文，另外比较喜欢问场景题，遇到某个问题可能是什么情况，有什么解决方法，比较灵活，但是也不会太难。</p>
<h3 id="garena">Garena</h3>
<p>上海，部门未定，流程很慢，HR 面后一直没消息，算是排序挂吧</p>
<h4 id="一面二面">一面，二面</h4>
<p>跟 Shopee 是一家人，面试体验也不错。做题只写了个二分，我还没写好😥……还是要基础牢靠啊，二分快排堆排归并啥的。其他都是常规的八股之类的，也有系统设计题。</p>
<h1 id="总结">总结</h1>
<ol>
<li>实习经历和学历对取得面试机会很重要</li>
<li>暑期实习不要太晚了，8月初要离职，不然影响秋招</li>
<li>项目要和岗位相关，还要吃透</li>
<li>题是要多刷的，这个属于小马过河，刷到什么程度看自己的情况</li>
<li>基础知识（八股）要牢靠，常规问题都搞明白，细节越清楚越好，Linux系统编程/内核知识、分布式是加分项</li>
<li>不要吊死在一棵树上，多拿几个 offer 才能谈个好的价格</li>
<li>最后感谢室友 H 神带我刷笔试（Hang 神牛逼）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（06）]]></title>
        <id>https://Miaite.github.io/post/rwAwSHvq2/</id>
        <link href="https://Miaite.github.io/post/rwAwSHvq2/">
        </link>
        <updated>2021-05-23T04:52:25.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 35~42。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 35~42。</p>
<!-- more -->
<h2 id="term-35优先选用基于任务而非基于线程的程序设计">Term 35：优先选用基于任务而非基于线程的程序设计</h2>
<ol>
<li><code>std::thread</code> 的 API 并未提供直接获取异步运算函数返回值的途径，而且如果函数出现异常，程序会终止</li>
<li>基于线程的程序设计要求手动管理处理线程资源耗尽、超订、负载均衡、跨平台等问题</li>
<li>使用 async 可以很大程度避免 2. 中的问题</li>
</ol>
<h2 id="term-36如果异步是必要的则指定-stdlaunchasync">Term 36：如果异步是必要的则指定 std::launch::async</h2>
<ol>
<li><code>std::async</code> 的默认启动策略不保证任务以异步方式执行</li>
<li>
<ol>
<li>中的方式可能导致线程局部变量不确定，任务永远无法完成（deferred 方式执行）等问题</li>
</ol>
</li>
<li>指定 <code>std::async</code> 的启动策略可以避免上述问题。<code>auto fut = std::async(std::launch::async | std::launch::deferred, f);</code></li>
</ol>
<h2 id="term-37使-stdtread-型别对象在所有路径都-unjionable">Term 37：使 std::tread 型别对象在所有路径都 unjionable</h2>
<p>unjionable 状态表示该 <code>std::tread</code> 处于安全结束的状态，在编写多线程程序时应当达到这个要求。然而考虑所有路径的情况是复杂的，包括 return、break、goto、异常跳出等多种情况，合适的方法是使用 RAII 对象来管理。</p>
<pre><code class="language-c++">class ThreadRAII {
 public:
  enum class DtorAction { join, detach };
  ThreadRAII(std::thread&amp;&amp; t, DtorAction a): action(a), t(std::move(t)) {}
  ~ThreadRAII() {
    if (t.joinable()) {
      if (action == DtorAction::join) {
        t.join();
      } else {
        t.detach();
      }
    }
  }
  ThreadRAII(ThreadRAII&amp;&amp;) = default;
  ThreadRAII&amp; operator=(ThreadRAII&amp;&amp;) = default;
  std::thread&amp; get() { return t; };
 private:
  DtorAction action;
  std::thread t;
};
</code></pre>
<h2 id="term-38对变化多端的线程-handle-析构函数行为保持关注">Term 38：对变化多端的线程 handle 析构函数行为保持关注</h2>
<ol>
<li>future 的正常析构⾏为就是销毁 future 本⾝的成员数据</li>
<li>最后⼀个引⽤ <code>std::async</code> 创建的共享状态的 future 的析构函数会在任务结束前保持阻塞</li>
</ol>
<h2 id="term-39考虑针对一次性事件通信使用以-void-为模板型别实参的-future">Term 39：考虑针对一次性事件通信使用以 void 为模板型别实参的 future</h2>
<pre><code class="language-c++">std::promise&lt;void&gt; p;
void detect() {
  auto sf = g.get_future().share();  // sf 的型别是 std::shared_future&lt;void&gt;
  std::vector&lt;std::thread&gt; vt;
  for (int i = 0; i &lt; threadsToRun; ++i) {
    vt.emplace_back([sf] {
      sf.wait();
      react();
    });
  }
  ...  // 若此段省略内容抛出异常，detect 函数会失去响应
  p.set_value();  // 让所有线程取消暂停
  ...
  for (auto&amp; t : vt) {  // make all threads unjoinable
    t.join();
  }
}
</code></pre>
<h2 id="term-40对并发使用-stdatomic对特种内存使用-volatile">Term 40：对并发使用 std::atomic，对特种内存使用 volatile</h2>
<ol>
<li><code>std::atomic</code> 用于多线程访问的数据，且不用于互斥量</li>
<li><code>volatile</code> 用于读写操作不可以被优化掉的内存，它会让编译器执行每一次内存操纵，而不能优化省略掉中间步骤（例如几条临近的语句都对同一个变量进行赋值的情形）</li>
</ol>
<h2 id="term-41针对可复制的形参在移动成本低且一定会被复制的前提下考虑将其按值传递">Term 41：针对可复制的形参，在移动成本低且一定会被复制的前提下，考虑将其按值传递</h2>
<ol>
<li>对于可复制的，移动成本低的，而且一定会被复制的形参而言，按值传递和按引用传递效率接近，而且按值传递目标代码更少</li>
<li>copy 构造函数拷贝形参可能比赋值运算符拷贝形参的成本高出不少</li>
<li>按值传递肯定会导致 slicing 问题，所以基类类型不适合按值传递</li>
</ol>
<h2 id="term-42考虑置入而非插入">Term 42：考虑置入而非插入</h2>
<p>以 <code>std::vector</code> 为例，置入是 emplace_back，插入是 push_back</p>
<ol>
<li>置入函数有时比插入更高效，且不会有比插入低效的可能</li>
<li>置入函数更高效情形的条件：1）待添加物的值是以构造而非赋值方式加入容器；2）传递的实参型别与容器内容物的型别不同；3）容器不会由于存在重复值而拒绝添加</li>
<li>置入函数可能会执行在插入函数中会被拒绝的型别转换</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（05）]]></title>
        <id>https://Miaite.github.io/post/wt6eTxymO/</id>
        <link href="https://Miaite.github.io/post/wt6eTxymO/">
        </link>
        <updated>2021-05-22T05:41:50.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 31~34。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 31~34。</p>
<!-- more -->
<h2 id="term-31避免默认捕获模式">Term 31：避免默认捕获模式</h2>
<p>默认捕获模式可能造成一些语义模糊，让我们误以为变量都是按值捕获，可以安全使用，实际上只有非静态局部变量才会按值捕获。当可能造成指针空悬时，我们应当明确把该变量复制到闭包。</p>
<h2 id="term-32使用初始化捕获将对象移入闭包">Term 32：使用初始化捕获将对象移入闭包</h2>
<p>C++14 中添加了广义捕获的特性，可以实现移动语义的捕获甚至是直接初始化一个对象放入闭包。在  C++11 则需要使用 <code>std::bind</code> 来模拟达成类似的效果。</p>
<pre><code class="language-c++">auto func = [_pw = std::move(pw)] {}  // pw 是一个 unique_ptr，_pw是闭包捕获的形参名
auto func = [pw = std::make_unique&lt;Foo&gt;()] {} // 这种广义”捕获“也是支持的
</code></pre>
<h2 id="term-33对-auto-型别的形参使用-decltype以-stdforward-之">Term 33：对 auto&amp;&amp; 型别的形参使用 decltype，以 std::forward 之</h2>
<pre><code class="language-c++">auto f = [](auto&amp;&amp;... params) {
  return func(std::forward&lt;decltype(params)&gt;(params)...); 
};
</code></pre>
<h2 id="term-34优先选用-lambda-式而非-stdbind">Term 34：优先选用 lambda 式，而非 std::bind</h2>
<p>对于 modern C++ 而言，使用 lambda 式在任何时候都是更优选，<code>std::bind</code> 唯一的作用式在 C++11（非 C++14） 中实现移动捕获和绑定模板化的函数调用运算符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（04）]]></title>
        <id>https://Miaite.github.io/post/JJa-UVHyT/</id>
        <link href="https://Miaite.github.io/post/JJa-UVHyT/">
        </link>
        <updated>2021-05-21T10:52:53.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 23~30。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 23~30。</p>
<!-- more -->
<h2 id="term-23理解-stdmove-和-stdforward">Term 23：理解 std::move 和 std::forward</h2>
<ol>
<li><code>std::move</code> 实施的是强制转换到右值型别</li>
<li>仅当传入的实参被绑定到右值时，<code>std::forward</code> 实施强制转换到右值型别</li>
<li><code>std::move</code> 和 <code>std::forward</code> 在运行期不做任何操作</li>
</ol>
<h2 id="term-24区分万能引用和右值引用">Term 24：区分万能引用和右值引用</h2>
<ol>
<li>如果函数模板形参是 <code>T&amp;&amp;</code> 形式（包括 <code>auto&amp;&amp;</code>），并且 T 依赖于型别推导，则为万能引用</li>
<li>如果 <code>T&amp;&amp;</code> 形式不依赖型别推导，则为右值引用</li>
<li>如果使用右值初始化万能引用，得到一个右值引用；使用左值初始化万能引用，则得到一个左值引用</li>
</ol>
<h2 id="term-25针对右值引用实施-stdmove针对万能引用实施-stdforward">Term 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h2>
<ol>
<li>针对右值引用的最后一次实施 <code>std::move</code>，针对万能引用的最后一次实施 <code>std::forward</code></li>
<li>作为按值返回的函数的右值引用和万能引用，依照 1. 中规则</li>
<li>如果按值返回局部对象，可能适用于返回值优化，不要使用 <code>std::move</code> 或者 <code>std::forward</code></li>
</ol>
<h2 id="term-26避免依万能引用型别进行重载">Term 26：避免依万能引用型别进行重载</h2>
<p>万能引用型别的重载函数会精确匹配一些程序员并无意图匹配的类型，应当谨慎使用，完美转发构造函数的问题更多。</p>
<h2 id="term-27熟悉依万能引用型别进行重载的替代方案">Term 27：熟悉依万能引用型别进行重载的替代方案</h2>
<p>使用 <code>std::enable_if</code> 对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。万能引用在性能方面有优势，但是良好的代码编写令人头疼，一个例子：</p>
<pre><code class="language-c++">class Person {
 public:
  template &lt;typename T,
            typename = std::enable_if_t&lt;    // 条件判断
                !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value &amp;&amp;  // 移除修饰词和引用特性，判断是否为 Person 的派生类
                !std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;::value&gt;&gt;  // 移除类型的引用，判断是否为整型
  explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {} // 接受 std::string 型别以及可以强制转换到 std::string 型别的实参的构造函数
  explicit Person(int idx) : name(nameFromIdx(idx)) {} // 接受整形实参的构造函数
  // copy 和 move 构造函数等
 private:
  std::string name;
};
</code></pre>
<h2 id="term-28理解引用折叠">Term 28：理解引用折叠</h2>
<p>引用折叠的规则：形参和实参都是引用类型时，只有两者都为右值引用，最终的参数类型才是右值引用，否者为左值引用。引用折叠可能出现在四种情况下：模板实例化、<code>auto</code> 型别生成、使用 <code>typedef</code> 和别名声明出现双重引用、<code>decaltype</code>。</p>
<h2 id="term-29假定移动操作不存在-成本高-未使用">Term 29：假定移动操作不存在、成本高、未使用</h2>
<p>在未知是否支持移动语义的情况下（比如编写模板），使用复制操作</p>
<h2 id="term-30熟悉完美转发的失败情形">Term 30：熟悉完美转发的失败情形</h2>
<p>完美转发失败是由于模板类型不能成功推导，或者结果错误，涉及的情形有：大括号初始物、以 0 或 NULL 表达的空指针、仅有声明的整形 <code>static const</code>  成员变量、模板或者重载的函数名字、位域</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/b8qoOdiHK/</id>
        <link href="https://Miaite.github.io/post/b8qoOdiHK/">
        </link>
        <updated>2021-05-20T14:14:12.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 18~22。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 18~22。</p>
<!-- more -->
<h2 id="term-18使用-stdunique_ptr-管理具备专属所有权的资源">Term 18：使用 std::unique_ptr 管理具备专属所有权的资源</h2>
<ol>
<li><code>std::unique_ptr</code> 是只移类型的智能指针，对托管资源有专属所有权</li>
<li>默认采用 delete 析构资源，也可以使用自定义函数作为删除器（通常是 lambda 函数），使用带状态的 lambda 函数或者函数指针作为删除器会增加智能指针对象大小</li>
<li><code>std::unique_ptr</code> 容易转换为 <code>std::shared_ptr</code></li>
</ol>
<h2 id="term-19使用-stdshared_ptr-管理具备共享所有权的资源">Term 19：使用 std::shared_ptr 管理具备共享所有权的资源</h2>
<ol>
<li><code>std::shared_ptr</code> 可复制可移动，计数管理</li>
<li><code>std::shared_ptr</code> 大小是裸指针的两倍，使用动态分配的控制块来管理，计数操作必须是原子性的</li>
<li>默认采用 delete 析构资源，也可以使用自定义函数作为删除器，删除器型别与 <code>std::shared_ptr</code> 型别无关</li>
<li>避免使用裸指针创建 <code>std::shared_ptr</code>，会创建多余的控制块，析构时出错</li>
</ol>
<h2 id="term-20对于类似-stdshared_ptr-但有可能空悬的指针使用-stdweak_ptr">Term 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h2>
<ol>
<li>使用 <code>std::weak_ptr</code> 代替可能空悬的 <code>std::shared_ptr</code>，<code>std::weak_ptr::lock</code> 返回一个 <code>std::shared_ptr</code>，若空悬其为空</li>
<li>可能会使用 <code>std::weak_ptr</code> 的场景：缓存，观察者列表，避免 <code>std::shared_ptr</code> 指针环路</li>
</ol>
<h2 id="term-21优先选用-stdmake_unique-和-stdmake_shared而非直接使用-new">Term 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h2>
<ol>
<li>相比于直接使用 new，make 系列函数代码简短，且异常安全，并且 <code>std::make_shared</code> 和 <code>std::allocated_shared</code> 生成的目标码更优</li>
<li>不适于使用 make 系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物</li>
<li>对于 <code>std::shared_ptr</code>，不建议使用 make 系列函数的额外场景有：自定义内存管理的类；内存紧张的系统，非常大的对象，以及存在比 <code>std::shared_ptr</code> 生存期更久的 <code>std::weak_ptr</code></li>
</ol>
<h2 id="term-22pimpl-习惯用法时将特殊成员函数的定义放到实现文件中">Term 22：Pimpl 习惯用法时，将特殊成员函数的定义放到实现文件中</h2>
<p>对于采用 <code>std::unique_ptr</code> 来实现的 pImpl 指针，需要在头文件中声明特种成员函数，但是在实现文件中实现他们（使用 <code>=default</code> 也可以）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（02）]]></title>
        <id>https://Miaite.github.io/post/y4q9kT2zz/</id>
        <link href="https://Miaite.github.io/post/y4q9kT2zz/">
        </link>
        <updated>2021-05-19T07:10:53.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 07~17。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 07~17。</p>
<!-- more -->
<h2 id="term-07在创建对象时注意区分-和">Term 07：在创建对象时注意区分 () 和 {}</h2>
<p>在 Term 2 中，我们了解到 <code>{val...}</code> 实际是 <code>std::initializer_list&lt;T&gt;</code> 类型，使用 <code>{}</code> 初始化需要注意：</p>
<ol>
<li>阻止隐式窄化型别转换</li>
<li><code>Foo f{};</code> 会调用 class Foo 的无参构造函数</li>
<li>如果一个类实现了 <code>std::initializer_list&lt;T&gt;</code> 为参数的构造函数，则除了 2. 之外，所有使用 <code>{}</code> 的情况都会最优先调用这个构造函数，因此除了明确调用 <code>std::initializer_list&lt;T&gt;</code> 为参数的构造函数的时候，其它情况都应该使用 <code>()</code></li>
<li><code>Foo f({});</code> 或者 <code>Foo f{{}};</code> 会调用 <code>std::initializer_list&lt;T&gt;</code> 为参数的构造函数，实参为空的 <code>std::initializer_list&lt;T&gt;</code></li>
<li>非静态成员变量不能使用 <code>()</code>，不可复制对象不能使用 <code>=</code> 操作符</li>
</ol>
<h2 id="term-08优先选用-nullptr而非-0-或者-null">Term 08：优先选用 nullptr，而非 0 或者 NULL</h2>
<p>使用 <code>nullptr</code> 表示空指针（任意类型指针），可以避免 0 或 NULL 错误调用 int 类型的重载</p>
<h2 id="term-09优先选用别名声明而非-typedef">Term 09：优先选用别名声明，而非 typedef</h2>
<p>使用别名声明，在函数指针上有优势，并且别名声明支持模板化，而 <code>typedef</code> 不支持。可以通过构造一个模板结构体/类，内嵌 <code>typedef</code> 声明变量来达到类似效果，但是比较繁琐。</p>
<pre><code class="language-c++">// using 写法
template&lt;typename T&gt;
using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;
MyAllocList&lt;Widget&gt; lw;
// typedef 写法
template&lt;typename T&gt;
struct MyAllocList {
    typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;
}
MyAllocList&lt;Widget&gt;::type lw;
</code></pre>
<h2 id="term-10优先选用限定作用域的枚举型别而非不限作用域的枚举型别">Term 10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h2>
<p>不限作用域的枚举型别，变量作用域是在外层，造成污染，使用限定作用域的枚举型别（<code>enum class</code>）可以避免这一情况。限定作用域的枚举型别需要强制类型转换，默认的底层类型是 int，可在声明式指定类型。</p>
<h2 id="term-11优先选用删除函数而非-private-未定义函数">Term 11：优先选用删除函数，而非 private 未定义函数</h2>
<p>当我们需要禁止编译器编写某个默认的类成员函数时（例如 copy 构造函数），我们可以使用 <code>Foo(const Foo&amp;) = delete</code> 告知编译器禁止生成该成员函数。除了成员函数之外，我们还可以声明其它函数为删除函数，用以避免隐式转换或者时处理特殊边界情况。</p>
<h2 id="term-12为意在改写的函数添加-override-声明">Term 12：为意在改写的函数添加 override 声明</h2>
<p>注意 overload 和 override 的区别 ，当我们意图 override 一个虚函数时，应该使用 <code>override</code> 让编译器检查这是否是合法的 override 行为。</p>
<h2 id="term-13优先选用-const_iterator而非-iterator">Term 13：优先选用 const_iterator，而非 iterator</h2>
<ol>
<li>优先选用 const_iterator，而非 iterator</li>
<li>优先选用非成员函数版本的 begin/cbegin 等，而非成员函数版本</li>
</ol>
<h2 id="term-14只要函数不会发射异常就为其加上-noexcept-声明">Term 14：只要函数不会发射异常，就为其加上 noexcept 声明</h2>
<p>添加 noexcept 声明使得编译器能更好地优化。</p>
<h2 id="term-15只要有可能使用-constexpr就使用它">Term 15：只要有可能使用 constexpr，就使用它</h2>
<ol>
<li><code>constexpr</code> 对象具备 const 属性，并切在编译期就已经知道其值</li>
<li>如果 <code>constexpr</code> 函数传入地实参是编译期已知的值，那么其结果会在编译期计算得出，否则退化为普通函数</li>
</ol>
<h2 id="term-16保证-const-成员函数的线程安全">Term 16：保证 const 成员函数的线程安全</h2>
<p>通常来说，只读属性是线程安全的。const 成员函数可以保证对象本身不变（除了 mutable 属性），但是 mutable 属性可能造成在读取成员属性时线程不安全（比如实现了缓存）。我们需要编写线程安全的代码避免这种情况。</p>
<h2 id="term-17理解特种成员函数的生成机制">Term 17：理解特种成员函数的生成机制</h2>
<ol>
<li>当我们没有为类编写特种成员函数，而代码中使用到了，编译器会自动替我们生成。他们包括：默认构造函数、析构函数、复制构造函数、复制赋值运算符、移动构造函数和移动赋值运算符</li>
<li>移动操作仅当类中没有显式声明复制操作、析构函数、移动操作时才会自动生成</li>
<li>复制构造函数、复制赋值运算符和析构函数，三者应该同时自定义或者同时都不自定义</li>
<li>使用 <code>=delete</code> 和 <code>=default</code> 声明特种成员函数是使代码更加明确的做法</li>
<li>成员函数模板不会抑制特种成员函数的生成</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective Modern C++ 笔记（01）]]></title>
        <id>https://Miaite.github.io/post/zawrgbFMU/</id>
        <link href="https://Miaite.github.io/post/zawrgbFMU/">
        </link>
        <updated>2021-05-18T07:29:52.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 01~06。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 01~06。</p>
<!-- more -->
<h2 id="term-01理解模板型别推导">Term 01：理解模板型别推导</h2>
<p>C++ 中的类型推导机制应用于模板、<code>auto</code> 和 <code>decaltype</code></p>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(ParamType param);    // ParamType 可以是  T/T*/T&amp; 等
f(expr) // call the function
</code></pre>
<ol>
<li>ParamType 是引用或者指针，但不是万能引用</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp; param);
int x = 1;
const int cx = x;
f(x);   // T: int, param: int&amp;
f(cx);   // T: const int, param: const int&amp;
</code></pre>
<ol start="2">
<li>ParamType 是万能引用，要区分实参是左值还是右值</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T&amp;&amp; param);
int x = 1;
const int cx = x;
f(x);   // T: int, param: int&amp;
f(cx);   // T: const int, param: const int&amp;
f(27);  // T: int, param: int&amp;&amp;
</code></pre>
<ol start="3">
<li>ParamType 是传值方式</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
void f(T param);
int x = 1;
const int cx = x;
f(x);   // T: int, param: int
f(cx);   // T: const int, param: int
</code></pre>
<ol start="4">
<li>数组实参和函数实参可以从引用退化为指针</li>
</ol>
<pre><code class="language-c++">template&lt;typename T&gt;
void f1(T param);
template&lt;typename T&gt;
void f2(T&amp; param);
// void myFunc(int param[]); 完全等价于 void myFunc(int *param);
const char name[] = &quot;J. P. Briggs&quot;; // name 的类型是 const char[13]
const char * ptrToName = name; // ptrToName 的类型是 const char *
f1(name); // T: const char *
f2(name); // T: const char(&amp;)[13]
</code></pre>
<h2 id="term-02理解-auto-型别推导">Term 02：理解 auto 型别推导</h2>
<p>auto 型别推导和 Term 1 中的模板基本一致，只需要注意两个特殊情况：</p>
<ol>
<li>统⼀初始化</li>
</ol>
<pre><code class="language-c++">auto x1={27};  // 类型是 std::initializer_list&lt;int&gt;,值是{27}
auto x2{27}; // 类型是 std::initializer_list&lt;int&gt;,值是{27}
</code></pre>
<ol start="2">
<li>auto 用于函数返回值或者 lambda 形参时，实际还是调用的模板推导机制</li>
</ol>
<h2 id="term-03理解-decaltype">Term 03：理解 decaltype</h2>
<p>通常情况 decaltype 是符合直觉的，注意两个特殊情形：</p>
<ol>
<li>用于函数返回值</li>
</ol>
<pre><code class="language-c++">template&lt;typename Container, typename Index&gt; // 传入容器（支持 [] 运算符）和下标，返回元素引用类型
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i){
    authenticateUser();
    return std::forward&lt;Container&gt;(c)[i];   // 用到了 std::forward 实现完美转发参数
}
</code></pre>
<ol start="2">
<li>左值表达式</li>
</ol>
<pre><code class="language-c++">int x = 0;
decltype((x));  // 推导为 int&amp;
</code></pre>
<h2 id="term-04掌握查看型别推导结果的方法">Term 04：掌握查看型别推导结果的方法</h2>
<ol>
<li>IDE</li>
<li>编译器错误信息</li>
</ol>
<pre><code class="language-c++">template &lt;typename T&gt; // 只对TD进⾏声明
class TD;
TD&lt;decltype(x)&gt; xType; // 引出错误消息，类似于，error: aggregate 'TD&lt;int&gt; xType' has incomplete type and cannot be defined
</code></pre>
<ol start="3">
<li>使用 <code>std::type_info::name</code> 或者 Boost.TypeIndex</li>
<li>以上方法都不完全可靠</li>
</ol>
<h2 id="term-05优先选用-auto而非显式型别声明">Term 05：优先选用 auto，而非显式型别声明</h2>
<p>尽量使用 <code>auto</code> 的优点：</p>
<ol>
<li>保证初始化</li>
<li>用来表示只有编译器才掌握的型别</li>
<li>避免初始化赋值时隐式类型转换</li>
</ol>
<h2 id="term-06当-auto-推导的型别不符合开发者本意时使用显式类型转换">Term 06：当 auto 推导的型别不符合开发者本意时，使用显式类型转换</h2>
<p>假设我们在使用一个代理类设计的类，或者需要显式转换类型，使用如下代码写法是更清晰明了的：</p>
<pre><code class="language-c++">auto index = static_cast&lt;int&gt;(d*c.size());  // c.size() 返回 float 类型的值
auto priority = static_cast&lt;bool&gt;(features[3]); // features 是std::vector&lt;bool&gt; 类型，features[3] 返回 std::vector&lt;bool&gt;::reference 类型
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（05）]]></title>
        <id>https://Miaite.github.io/post/ofvXkwiwL/</id>
        <link href="https://Miaite.github.io/post/ofvXkwiwL/">
        </link>
        <updated>2021-04-28T06:37:10.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 30~35。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 30~35。</p>
<!-- more -->
<h2 id="term-30proxy-classes替身类-代理类">Term 30：Proxy classes（替身类、代理类）</h2>
<p>Proxy classes 的作用：</p>
<ol>
<li>多维数组，<code>operator []</code> 返回次级数组</li>
<li>左值/右值的区分</li>
<li>压抑隐式转换</li>
</ol>
<h2 id="term-31让函数根据一个以上的对象类型来决定如何虚化">Term 31：让函数根据一个以上的对象类型来决定如何虚化</h2>
<p>假设我们的一个函数，接收两个对象参数，需要根据具体两个对象来确定实施什么操作，几种思路：</p>
<ol>
<li>虚函数 + RTTI（运行时期类型辨识）：编写多个 if-else 的判断，判断对象类型再操作（可以遇见，这是个糟糕的做法，除非类别有限且固定）</li>
<li>只使用虚函数：重载不同的传入参数，函数体内调用 <code>this</code>，则只需要维护单个参数的不同类型即可</li>
<li>仿照虚函数表，创建多个成员函数，效果类似上一条</li>
<li>使用“非成员（Non-Member）函数”，接收两个参数。初始化一个 map 存储不同类型对的函数指针，再非成员函数体中间接获取并调用这个函数指针</li>
</ol>
<h2 id="term-32在未来时态下发展程序">Term 32：在未来时态下发展程序</h2>
<ol>
<li>提供完整的 classes ——即使某些部分目前用不到。当新的需求进来，你不太需要回头去修改那些 classes</li>
<li>设计你的接口，使有利于共同的操作行为，阻止共同的错误</li>
<li>尽量使你的代码一般化（泛化），除非有不良的巨大后果</li>
</ol>
<h2 id="term-33将非尾端类non~leaf-classes设计为抽象类abstract-classes">Term 33：将非尾端类（non～leaf classes）设计为抽象类（abstract classes）</h2>
<p>这样可以阻止一些不可靠的行为，限制基类指针的行为。</p>
<h2 id="term-34如何在同一个程序中结合-c-和-c">Term 34：如何在同一个程序中结合 C++ 和 C</h2>
<ol>
<li>将双方都使用的函数声明为  <code>extern &quot;C&quot;</code></li>
<li>如果可能，尽量在 C++中撰写 main</li>
<li>new/delete 和 malloc/free 分开配对使用</li>
<li>将两个语言间的“数据结构传递”限制于 C 所能了解的形式；C++structs 如果内含非虚函数，倒是不受此限</li>
</ol>
<h2 id="term-35让自己习惯于标准-c-语言">Term 35：让自己习惯于标准 C++ 语言</h2>
<p>尽量使用 C++ 风格和标准的库函数，语法等等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（04）]]></title>
        <id>https://Miaite.github.io/post/IwsB4nl6k/</id>
        <link href="https://Miaite.github.io/post/IwsB4nl6k/">
        </link>
        <updated>2021-04-27T11:28:50.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 25~29。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 25~29。</p>
<!-- more -->
<h2 id="term-25将-constructor-和-non-member-functions-虚化">Term 25：将 constructor 和 non-member functions 虚化</h2>
<ol>
<li>事实上构造函数不能是虚函数，但某些情况下，我们可能需要使用虚函数性质的 constructor，这时候，我们可以创建一个虚函数 <code>clone()</code>，在 <code>clone</code> 中调用构造函数。</li>
<li>类似的，non-member functions 也不能是虚函数，但是我们可以定义一个接口函数，接收基类，再调用类中的虚函数，达成类似的效果。</li>
</ol>
<h2 id="term-26限制某个-class所能产生的对象数量">Term 26：限制某个 class所能产生的对象数量</h2>
<p>最好的做法是设计一个用来计算对象个数的 Base Class，</p>
<pre><code class="language-c++">template &lt;typename T&gt;
class Counted {
 public:
  class TooManyObjects {};  // 会被抛出的异常
  static int objectCount() { return numObjects; };
 protected
     :  // 构造函数和析构函数定义为 protected，并且 Counted 类应被 private 继承
  Counted();
  // 省略其它构造函数，实现中应调用 init()
  ~Counted() { --numObjects; };
 private:  // numObjects 和 maxObjects 定义为 stactic，实现对象计数
  static int numObjects;
  static const size_t maxObjects;
  void init();
};
template &lt;typename T&gt;
int Counted&lt;T&gt;::numObjects = 0;
template &lt;typename T&gt;
Counted&lt;T&gt;::Counted() {
  init();
}
template &lt;typename T&gt;
void Counted&lt;T&gt;::init() {
  if (numObjects &gt;= maxObjects) throw TooManyObjects();
  ++numObjects;
}

// 私有继承 Counted
class Foo : private Counted&lt;Foo&gt; {
 public:  // 通过 newFoo 间接调用构造函数
  static Foo* newFoo();
  using Counted&lt;Foo&gt;::objectCount;
  ~Foo();
 private:  // 构造函数私有
  Foo(){};
};
template &lt;&gt;
const size_t Counted&lt;Foo&gt;::maxObjects = 10;  // 继承 Counted 时指定 maxObjects
Foo* Foo::newFoo() { return new Foo(); }
</code></pre>
<h2 id="term-27要求或禁止对象产生于-heap-之中">Term 27：要求（或禁止）对象产生于 heap 之中</h2>
<ol>
<li>要求对象产生于 heap 之中：将构造或者析构函数设置为非 public 即可</li>
<li>判断对象是否在 heap 中：编写一个基类，重载 <code>operator new</code>，调用 new 的时候把指针存入一个 list（数组，vector 之类的也可以），设置一个接口函数，判断当前对象的指针是否在 list 当中。继承这个类的派生类，通过接口可以判断对象是否在 heap 中</li>
<li>禁止对象产生于 heap 之中：将 <code>operator new/delete</code> 设置为非 public 即可</li>
</ol>
<h2 id="term-28smart-pointers智能指针">Term 28：Smart Pointers（智能指针）</h2>
<p>智能指针使得一下几件事情更加有控制权：</p>
<ol>
<li>构造和析构</li>
<li>复制和赋值（Copying and Assignment）</li>
<li>解引（Dereferencing）</li>
</ol>
<h2 id="term-29reference-counting引用计数">Term 29：Reference counting（引用计数）</h2>
<p>适合使用引用计数类的场景：</p>
<ol>
<li>相对多数的对象共享相对少量的实值</li>
<li>对象实值的产生或销毁成本很高，或是它们使用许多内存</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/LQ41yj2Me/</id>
        <link href="https://Miaite.github.io/post/LQ41yj2Me/">
        </link>
        <updated>2021-04-26T07:21:52.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 16~24。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 16~24。</p>
<!-- more -->
<h2 id="term-16谨记-80-20-法则">Term 16：谨记 80-20 法则</h2>
<p>一个程序 80%的资源用于 20%的代码身上。依靠经验和程序分析器（program profiler），判断程序的瓶颈所在。</p>
<h2 id="term-17考虑使用-lazy-evaluation缓式评估">Term 17：考虑使用 lazy evaluation（缓式评估）</h2>
<p>一个例子，linux 中创建子进程的时候，不会将父进程的资源复制给子进程，而是让子进程共享父进程的资源。如果我们只读取而没有修改数据，则子进程永远不需要复制一份资源，当需要修改数据时，内核才会为子进程复制一份资源。</p>
<p>不仅是复制，矩阵运算，数据库查询等等，可能我们并不需要全部的结果，只需要一部分即可。</p>
<h2 id="term-18分期摊还预期的计算成本">Term 18：分期摊还预期的计算成本</h2>
<p>一个例子，Python 中的 list 的 length 属性是作为变量存储在对象当中，并且在数据长度发生变化时同步更新，这样使得 <code>len(list)</code> 的时间复杂度为 O(1)。</p>
<h2 id="term-19了解临时对象的来源">Term 19：了解临时对象的来源</h2>
<ol>
<li>当对象以 by value （传值）方式传递，或是当对象被传递给一个reference-to-const 参数时，编译器会创建一个临时对象使得函数成功调用</li>
<li>函数 by value 返回一个对象时，也是临时变量</li>
<li>字面量也是临时变量</li>
</ol>
<h2 id="term-20协助完成返回值优化rvo">Term 20：协助完成“返回值优化（RVO）”</h2>
<p>我们知道函数不应该返回函数中创建的变量的指针或者引用，只能 by value 返回。</p>
<pre><code class="language-c++">return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());
</code></pre>
<p>如果我们以类似上面这种形式返回一个构造函数的调用，那么结果不会出现临时变量再被复制一次的情况，这种做法叫做返回值优化，已经被编译器广泛使用，我们不需要操心去编写构造函数形式的返回值了。甚至在现代 C++ 中我们还可以使用右值引用直接绑定临时变量。</p>
<h2 id="term-21利用重载技术overload避免隐式类型转换implicittype-conversions">Term 21：利用重载技术（overload）避免隐式类型转换（implicittype conversions）</h2>
<p>为了避免函数调用（包括操作符函数）时隐式类型转换产生临时变量，我们可以编写多个函数，提供不同的参数类型完成相同逻辑的操作。</p>
<h2 id="term-22考虑以操作符复合形式op取代其独身形式op">Term 22：考虑以操作符复合形式（op=）取代其独身形式（op）</h2>
<p>操作符的“复合版本”（例如，operator+=）比其对应的“独身版本”（例如，operator+）有着更高效率的倾向，因为不需要创建对象存放结果。身为一位程序库设计者，你应该两者都提供，通常的做法是在“独身版本”中调用“复合版本”，提高代码复用；身为一位应用软件开发者，如果性能是重要因素的话，你应该考虑以“复合版本”操作符取代其“独身版本”。</p>
<h2 id="term-23考虑使用其他程序库代替标准库">Term 23：考虑使用其他程序库代替标准库</h2>
<p>例如 iostream 程序库具有类型安全（type-safe）特性，并且可扩充。然而在效率方面，iostream 通常表现得比 stdio 差，因为 stdio 的可执行文件通常比 iostreams更小也更快。</p>
<h2 id="term-24了解-virtual-functions-multiple-inheritance-virtualbase-classes-runtime-type-identification的成本">Term 24：了解 virtual functions、multiple inheritance、virtualbase classes、runtime type identification的成本</h2>
<p>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。对象的 pointer 或reference，其类型是无形的，编译器如何很有效率地提供这样的行为呢？大部分编译器使用所谓的 virtual tables 和 virtual table pointers——此二者常被简写为 vtbls 和 vptrs。每一个类会维护自己的 vtbls 和 vptrs，派生类不仅有自己的 vtbls 内容，还包含基类的 vtbls 内容。当继承关系变得复杂时，vptrs 会使对象的内存空间大量增加。另外，使用虚函数，inline 便会失效，因为在编译阶段无法知道要调用哪一个具体函数。</p>
]]></content>
    </entry>
</feed>