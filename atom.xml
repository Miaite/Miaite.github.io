<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2020-11-07T08:17:36.256Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些流水账，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/386I6Xacv/</id>
        <link href="https://Miaite.github.io/post/386I6Xacv/">
        </link>
        <updated>2020-11-07T07:42:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
<!-- more -->
<h2 id="term-13以对象管理资源">Term 13：以对象管理资源</h2>
<p>编写 C++ 程序容易遇到的一个问题就是内存泄漏，手动 <code>delete</code> 容易遇到各种问题。一个较好的解决方案是使用类来管理资源，通过析构过程保证资源的正确释放。</p>
<ol>
<li>使用 RAII 对象，在其构造函数中获取资源，析构函数中释放资源</li>
<li>常用的 RAII 对象，智能指针，shared_ptr 和 unique_ptr</li>
</ol>
<h2 id="term-14在资源管理类中小心-copying-行为">Term 14：在资源管理类中小心 copying 行为</h2>
<p>可选的策略有：</p>
<ol>
<li>禁止复制</li>
<li>引用计数</li>
<li>深拷贝</li>
<li>转移所有权（auto_ptr 那样的行为）</li>
</ol>
<h2 id="term-15在资源管理类中提供对原始资源的访问">Term 15：在资源管理类中提供对原始资源的访问</h2>
<p>RAII class 应当提供一个直接获取到原始资源（指针/引用）的方法。一般来说，显示转换比较安全，隐式转换比较方便。</p>
<h2 id="term-16成对使用-new-和-delete-时要采取相同形式">Term 16：成对使用 new 和 delete 时要采取相同形式</h2>
<p>如果在 <code>new</code> 时使用了 <code>[]</code>，那么在 <code>delete</code> 时也应使用 <code>[]</code>，未使用 <code>[]</code> 时同样要准寻这个原则，以避免释放资源出错。</p>
<h2 id="term-17以独立语句将-newed-对象置入智能指针">Term 17：以独立语句将 newed 对象置入智能指针</h2>
<p>要以独立语句将 newed 对象置入智能指针，否则可能发生难以察觉的资源泄漏</p>
<pre><code>// 首先有以下定义
int priority();
void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);
// 几种调用
processWidget(new Widget, priority());    // 出错，shared_ptr 无法隐式转换
processWidget(std::tr1::shared_ptr&lt;Widget&gt; (new Widget), priority());    // 虽然可以通过编译，但是假如 priority() 先于 shared_ptr 的构造函数执行且出现异常，则资源泄漏
// 下面时正确做法
std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);
processWidget(pw, priority());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（02）]]></title>
        <id>https://Miaite.github.io/post/ol7D4iZKg/</id>
        <link href="https://Miaite.github.io/post/ol7D4iZKg/">
        </link>
        <updated>2020-11-05T11:45:07.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
<!-- more -->
<h2 id="term-05了解-c-默默编写并调用了哪些函数">Term 05：了解 C++ 默默编写并调用了哪些函数</h2>
<p>编译器会为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符以及析构函数，它们都是 public 以及 inline 的。注意到，当 copy assignment 操作符在父类中被声明为 private 或者含有 const 成员面对等情况，编译器不会自动创建 copy assignment 操作符；编译器自动创建的析构函数不是虚函数，除非继承自虚函数。</p>
<h2 id="term-06若不想使用编译器自动生成的函数就应该明确拒绝">Term 06：若不想使用编译器自动生成的函数，就应该明确拒绝</h2>
<p>通过 Term 05 我们知道编译器会自动生成一些成员函数，但有时我们可能不需要这种功能。解决方法：</p>
<ol>
<li>将该成员函数声明为 private 并且不予实现</li>
<li>按照 1. 构建一个基类，然后去继承它</li>
<li>使用 C++(11) 提供的 <code>=default</code> 和 <code>=delete</code> 显式启用或者禁用编译器自动版本的函数</li>
</ol>
<h2 id="term-07为多态基类声明-virtual-析构函数">Term 07：为多态基类声明 virtual 析构函数</h2>
<ol>
<li>用作多态的基类应该声明 virtual 析构函数。如果 class 带有 virtual 成员函数，应该声明 virtual 析构函数</li>
<li>不是基类或者不是用作多态的基类，不应该声明 virtual 析构函数，比如 STL 容器</li>
<li>以上两点可以避免内存泄漏</li>
</ol>
<h2 id="term-08别让异常逃离析构函数">Term 08：别让异常逃离析构函数</h2>
<p>不应该在析构函数内抛出异常，保证析构函数能执行。将可能造成异常的部分移到另一个函数内或者交给用户自己处理。在 C++(11) 中，可以使用 <code>noexcept</code> 来限制函数，如果出现异常会直接终止程序。</p>
<h2 id="term-09绝不在构造和析构过程中调用-virtual-函数">Term 09：绝不在构造和析构过程中调用 virtual 函数</h2>
<p>如果在 base class 构造和析构过程中调用 virtual 函数，该函数的版本是 base class 对应的版本，不会是意图的 derived class 版本。</p>
<h2 id="term-10令-operator-返回一个-reference-to-this">Term 10：令 operator= 返回一个 reference to *this</h2>
<p>可以实现右结合的连锁赋值，大家都这么做，一种习惯性接口。</p>
<h2 id="term-11在-operator-中处理自我赋值">Term 11：在 operator= 中处理“自我赋值”</h2>
<ol>
<li>如果将一个对象赋值给自身，会造成安全问题。处理方法可以是：通过地址判断是否是同一对象；安排安全的语句顺序；copy-and-swap</li>
<li>任何函数，如果操作多个对象，要考虑其中某些对象其实是同一个这种情况</li>
</ol>
<h2 id="term-12复制对象时勿忘每一个成分">Term 12：复制对象时勿忘每一个成分</h2>
<ol>
<li>copy 构造函数和 copy 赋值操作符会执行拷贝</li>
<li>拷贝对象时应该把每个成员变量都考虑到，并且调用对应的 base class 的函数</li>
<li>copy 构造函数和 copy 赋值操作符之间<strong>不能</strong>互相调用，可以考虑新创建一个成员函数维护冗余代码，然后在 copy 操作时调用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（01）]]></title>
        <id>https://Miaite.github.io/post/UyR9S6D5b/</id>
        <link href="https://Miaite.github.io/post/UyR9S6D5b/">
        </link>
        <updated>2020-11-03T11:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
]]></summary>
        <content type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
<!-- more -->
<h2 id="term-01视-c-为一个语言联邦">Term 01：视 C++ 为一个语言联邦</h2>
<p>这一点说起来容易（做起来难）。简单讲，C++ 的语言设计其实有四个部分 ：（兼容）C、面向对象、泛型和模板、STL，这四个部分相互关联却又在设计思想上相对独立。每一个部分都会有一些不同的准则，在 C 中的常用思路不一定适合在泛型和模板中使用。</p>
<p>一般来说，泛型和模板这一部分是 C++ 程序员最薄弱的，需要特别注意。</p>
<h2 id="term-02尽量以-const-enum-inline-替换-define">Term 02：尽量以 const, enum, inline 替换 #define</h2>
<ol>
<li>对于常量，使用 const 或者 enum hack 代替</li>
<li>对于形似函数的宏定义，使用 inline 函数代替（可能会用到模板）</li>
</ol>
<pre><code>// enum hack 的例子：
class Game {
    private:
        static const int GameTurn = 10;
        int scores[GameTurn];
};    //不支持类内初始化的编译器报错
class GamePlayer{
    private:
        enum {NumTurns = 5};
        int scores[NumTurns];
};    //不支持类内初始化的编译器也能编译通过
</code></pre>
<h2 id="term-03尽可能使用-const">Term 03：尽可能使用 const</h2>
<ol>
<li>const 和指针：记住 <code>const</code> 出现在 <code>*</code> 左边，表示被指物是常量；如果出现在 <code>*</code> 右边，表示指针自身是常量；如果出现在 <code>*</code> 两边，表示被指物和指针都是常量</li>
<li>STL 的迭代器可以视为指针，<code>const std::vector&lt;int&gt;::iterator iter</code> 效果等同于 <code>T* const</code>，<code>std::vector&lt;int&gt;::const_iterator cIter</code> 效果等同于 <code>const T*</code></li>
<li>设置函数返回对象为 const 可以排除一些不必要的安全隐患</li>
<li>类的成员函数可以通过（函数名之后，函数体之前的那个） <code>const</code> 重载，分别针对 const/non-const 对象</li>
<li>bitwise const 和 logical const 的区别，通过 <code>mutable</code> 实现 logical const</li>
<li>当成员函数的 const/non-const 版本有同样的实现时，可以将实现代码写在 const 版本中，而在 non-const 版本中调用即可，但是需要注意<strong>转换类型</strong>，并且一定要小心，避免安全隐患。</li>
</ol>
<pre><code>class TextBlock {
 public:
  const char&amp; operator[](std::size_t position) const { return text[position]; }
  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);
  }
  // ......
};
</code></pre>
<h2 id="term-04确定对象被使用前已被初始化">Term 04：确定对象被使用前已被初始化</h2>
<ol>
<li>手动初始化内置型对象，比如 <code>int i = 0;</code></li>
<li>构造函数使用成员初值表进行初始化</li>
<li>为免除“跨编译单元初始化顺序不确定”问题，使用 local static 对象替换 static 对象</li>
</ol>
]]></content>
    </entry>
</feed>