<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2021-04-26T07:23:23.345Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些流水账，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/LQ41yj2Me/</id>
        <link href="https://Miaite.github.io/post/LQ41yj2Me/">
        </link>
        <updated>2021-04-26T07:21:52.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 16~24。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 16~24。</p>
<!-- more -->
<h2 id="term-16谨记-80-20-法则">Term 16：谨记 80-20 法则</h2>
<p>一个程序 80%的资源用于 20%的代码身上。依靠经验和程序分析器（program profiler），判断程序的瓶颈所在。</p>
<h2 id="term-17考虑使用-lazy-evaluation缓式评估">Term 17：考虑使用 lazy evaluation（缓式评估）</h2>
<p>一个例子，linux 中创建子进程的时候，不会将父进程的资源复制给子进程，而是让子进程共享父进程的资源。如果我们只读取而没有修改数据，则子进程永远不需要复制一份资源，当需要修改数据时，内核才会为子进程复制一份资源。</p>
<p>不仅是复制，矩阵运算，数据库查询等等，可能我们并不需要全部的结果，只需要一部分即可。</p>
<h2 id="term-18分期摊还预期的计算成本">Term 18：分期摊还预期的计算成本</h2>
<p>一个例子，Python 中的 list 的 length 属性是作为变量存储在对象当中，并且在数据长度发生变化时同步更新，这样使得 <code>len(list)</code> 的时间复杂度为 O(1)。</p>
<h2 id="term-19了解临时对象的来源">Term 19：了解临时对象的来源</h2>
<ol>
<li>当对象以 by value （传值）方式传递，或是当对象被传递给一个reference-to-const 参数时，编译器会创建一个临时对象使得函数成功调用</li>
<li>函数 by value 返回一个对象时，也是临时变量</li>
<li>字面量也是临时变量</li>
</ol>
<h2 id="term-20协助完成返回值优化rvo">Term 20：协助完成“返回值优化（RVO）”</h2>
<p>我们知道函数不应该返回函数中创建的变量的指针或者引用，只能 by value 返回。</p>
<pre><code class="language-c++">return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());
</code></pre>
<p>如果我们以类似上面这种形式返回一个构造函数的调用，那么结果不会出现临时变量再被复制一次的情况，这种做法叫做返回值优化，已经被编译器广泛使用，我们不需要操心去编写构造函数形式的返回值了。甚至在现代 C++ 中我们还可以使用右值引用直接绑定临时变量。</p>
<h2 id="term-21利用重载技术overload避免隐式类型转换implicittype-conversions">Term 21：利用重载技术（overload）避免隐式类型转换（implicittype conversions）</h2>
<p>为了避免函数调用（包括操作符函数）时隐式类型转换产生临时变量，我们可以编写多个函数，提供不同的参数类型完成相同逻辑的操作。</p>
<h2 id="term-22考虑以操作符复合形式op取代其独身形式op">Term 22：考虑以操作符复合形式（op=）取代其独身形式（op）</h2>
<p>操作符的“复合版本”（例如，operator+=）比其对应的“独身版本”（例如，operator+）有着更高效率的倾向，因为不需要创建对象存放结果。身为一位程序库设计者，你应该两者都提供，通常的做法是在“独身版本”中调用“复合版本”，提高代码复用；身为一位应用软件开发者，如果性能是重要因素的话，你应该考虑以“复合版本”操作符取代其“独身版本”。</p>
<h2 id="term-23考虑使用其他程序库代替标准库">Term 23：考虑使用其他程序库代替标准库</h2>
<p>例如 iostream 程序库具有类型安全（type-safe）特性，并且可扩充。然而在效率方面，iostream 通常表现得比 stdio 差，因为 stdio 的可执行文件通常比 iostreams更小也更快。</p>
<h2 id="term-24了解-virtual-functions-multiple-inheritance-virtualbase-classes-runtime-type-identification的成本">Term 24：了解 virtual functions、multiple inheritance、virtualbase classes、runtime type identification的成本</h2>
<p>当一个虚函数被调用，执行的代码必须对应于“调用者（对象）的动态类型”。对象的 pointer 或reference，其类型是无形的，编译器如何很有效率地提供这样的行为呢？大部分编译器使用所谓的virtual tables 和 virtual table pointers——此二者常被简写为 vtbls 和 vptrs。每一个类会维护自己的 vtbls 和 vptrs，派生类不仅有自己的 vtbls 内容，还包含基类的 vtbls 内容。当继承关系变得复杂时，vtbls 会使对象的内存空间大量增加。另外，使用虚函数，inline 便会失效，因为在编译阶段无法知道要调用哪一个具体函数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（02）]]></title>
        <id>https://Miaite.github.io/post/A-SVzsdLw/</id>
        <link href="https://Miaite.github.io/post/A-SVzsdLw/">
        </link>
        <updated>2021-04-25T06:38:46.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 9~15。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 9~15。</p>
<!-- more -->
<h2 id="term-9利用-destructors-避免泄漏资源">Term 9：利用 destructors 避免泄漏资源</h2>
<p>按照 RAII，将资源放入对象当中，通过析构函数可以保证资源被正确回收。通常情况只需要使用智能指针即可，即使发生异常也能保证不出现资源泄露。</p>
<h2 id="term-10在-constructors-内阻止资源泄漏resource-leak">Term 10：在 constructors 内阻止资源泄漏（resource leak）</h2>
<p>如果构造函数在执行过程中发生异常，可能会出现资源泄露，此时需要捕获异常并处理。简单来说，使用智能指针就好了。</p>
<h2 id="term-11禁止异常exceptions流出-destructors-之外">Term 11：禁止异常（exceptions）流出 destructors 之外</h2>
<ol>
<li>可以避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制中被调用</li>
<li>可以协助确保 destructors 完成其应该完成的所有事情</li>
</ol>
<h2 id="term-12了解抛出一个-exception与传递一个参数或调用一个虚函数之间的差异">Term 12：了解“抛出一个 exception”与“传递一个参数”或“调用一个虚函数”之间的差异</h2>
<ol>
<li>exception objects 总是会被复制，如果以 by value 方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。</li>
<li>“被抛出成为 exceptions”的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。</li>
<li>catch 子句以其“出现于源代码的顺序”被编译器检验比对，其中第一个匹配成功者便执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。</li>
<li>“exceptions 与 catch 子句相匹配”的过程中，仅有两种转换可以发生。第一种是“继承架构中的类转换（inheritance-based conversions）”。第二个允许发生的转换是从一个“有型指针”转为“无型指针”，所以一个针对 const void＊ 指针而设计的 catch子句，可捕捉任何指针类型的 exception。</li>
</ol>
<h2 id="term-13以-by-reference-方式捕捉-exceptions">Term 13：以 by reference 方式捕捉 exceptions</h2>
<ol>
<li>by pointer 方式捕捉不能保证指针指向有效对象，该对象可能离开作用域就被销毁</li>
<li>by value 方式复制两次效率低下，此外它也会引起切割（slicing）问题，因为 derived class exception objects被捕捉并被视为 base classexceptions 者，将失去其派生成分</li>
</ol>
<h2 id="term-14明智运用-exception-specifications">Term 14：明智运用 exception specifications</h2>
<p>exception specifications 对于“函数希望抛出什么样的 exceptions”提供了卓越的说明。而在“违反 exception specification的下场十分悲惨，以至于需要立刻结束程序”的形势下，它们提供了默认行为。但是虽然有这些好处，它们相对也有一些缺点，包括编译器只对它们做局部性检验、很容易被不经意地违反等。此外它们可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions——即使更上层的处理函数已经知道该怎么做。</p>
<h2 id="term-15了解异常处理exception-handling的成本">Term 15：了解异常处理（exception handling）的成本</h2>
<p>异常处理需要额外的成本，需要谨慎决定使用异常处理机制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[More Effective C++ 笔记（01）]]></title>
        <id>https://Miaite.github.io/post/sGv0WnrMz/</id>
        <link href="https://Miaite.github.io/post/sGv0WnrMz/">
        </link>
        <updated>2021-04-21T10:27:52.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 1~8。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 1~8。</p>
<!-- more -->
<h2 id="term-1仔细区别-pointers和-references">Term 1：仔细区别 pointers和 references</h2>
<p>引用也是由指针实现的，引用的特别之处在于：</p>
<ol>
<li>必须初始化，不会为空</li>
<li>引用类似于 <code>Type* cosnt ptr</code>，永远指向初始化时的对象</li>
<li>引用是一种别名，不需要用 <code>*</code> dereference</li>
<li>重载操作符时使用指针可能会造成语义混淆，应当使用引用</li>
</ol>
<h2 id="term-2最好使用-c-转型操作符">Term 2：最好使用 C++ 转型操作符</h2>
<ol>
<li><code>static_cast</code> 普通转换</li>
<li><code>const_cast</code> 去掉 const 属性，但仍然不能改变常量值，只是为了满足参数调用的类型</li>
<li><code>dynamic_cast</code> 把指向基类的指针/引用转换成指向其派生类或其兄弟类的指针/引用，失败则返回空指针或者抛出异常</li>
<li><code>reinterpret_cast</code> 转换函数指针（不推荐使用，没有跨平台标准保证）</li>
</ol>
<h2 id="term-3绝对不要以多态polymorphically方式处理数组">Term 3：绝对不要以多态（polymorphically）方式处理数组</h2>
<p>假设有这样一个函数，参数为基类对象的数组，如果使用派生类对象数组作为参数，调用这个函数，将会出现无法预期的错误，因为 <code>sizeof(基类对象) != sizeof(派生类对象)</code></p>
<h2 id="term-4非必要不提供-default-constructor">Term 4：非必要不提供 default constructor</h2>
<p>如果一个类不提供无参的构造函数，可能造成需要需要调用无参构造函数情况下的错乱（比如声明对象数组或者模板类内部的 new）。但是在良好设计的情况下，不提供无参的构造函数，可以保证每一个对象都得到了有效初始化，不需要在使用对象时进行检查。</p>
<h2 id="term-5对定制的类型转换函数保持警觉">Term 5：对定制的“类型转换函数”保持警觉</h2>
<p>应当避免编译器的隐式类型转换：</p>
<ol>
<li>对提供单参数（可能包含默认参数）的构造函数使用 <code>explicit</code> 关键字</li>
<li>不提供隐式类型转换操作符方法（形如 <code>operator double() const{}</code>），提供单独的方法。</li>
</ol>
<h2 id="term-6区别-incrementdecrement-操作符的前置prefix和后置postfix形式">Term 6：区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式</h2>
<p>也就是 C++ 中令人深恶痛绝的 <code>i++</code> 和 <code>++i</code>，在重载操作符时只维护前缀形式即可，后缀形式自动与前缀形式的行为一致。前缀形式返回该类型引用，后缀形式返回 const 该类型。</p>
<h2 id="term-7千万不要重载-和-操作符">Term 7：千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符</h2>
<p>除了 Term 中提到的操作符外，还有很多操作符不应该被重载，否者会造成语义混淆。在重载操作符时应该考虑清楚，这是为了方便编写程序，并且修改的部分是可控的（比如 <code>new</code>、<code>&lt;=</code>、<code>++</code>）</p>
<h2 id="term-8理解各种不同含义的-new-和-delete">Term 8：理解各种不同含义的 new 和 delete</h2>
<p>在使用 new operator 的时候，实际上是执行了三个步骤:</p>
<ol>
<li>调用类中的 operator new 分配内存</li>
<li>调用构造函数生成对象</li>
<li>返回指针</li>
</ol>
<p>如果你希望将对象产生于 heap，请使用 newoperator。它不但分配内存而且为该对象调用一个constructor。如果你只是打算分配内存，请调用operator new，那就没有任何 constructor 会被调用。如果你打算在 heap objects 产生时自己决定内存分配方式，请写一个自己的 operator new，并使用 new operator，它将会自动调用你所写的 operator new。如果你打算在已分配（并拥有指针）的内存中构造对象，请使用 placement new。placement new 的使用形式：<code>MyClass * pClass = new(buf) MyClass;</code>。</p>
<p>如果交给 placement new 的原始内存（raw memory）本身是动态分配而得（通过某种非传统做法），那么你最终还是得释放那块内存，以免内存泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快排的四种写法]]></title>
        <id>https://Miaite.github.io/post/M4PxdwkA_/</id>
        <link href="https://Miaite.github.io/post/M4PxdwkA_/">
        </link>
        <updated>2021-03-17T02:07:07.000Z</updated>
        <summary type="html"><![CDATA[<p>快速排序是常见的排序算法，可分为 partition 和 recursion 两个部分，至于 partition 的具体实现，有一些不同的方式可选。</p>
]]></summary>
        <content type="html"><![CDATA[<p>快速排序是常见的排序算法，可分为 partition 和 recursion 两个部分，至于 partition 的具体实现，有一些不同的方式可选。</p>
<!-- more -->
<p>本文使用 Python 且不对数据的合法性进行判断，前提要求是对一个列表类型的数组 <code>nums</code> 进行原地排序。</p>
<pre><code class="language-Python"># 先来一个最简单的，其实用的是 Timsort
nums.sort()
</code></pre>
<h3 id="方法1填坑">方法1：填坑</h3>
<p>也就是<a href="https://book.douban.com/subject/2024655/">教材</a>上使用的方法</p>
<pre><code class="language-Python"># 不同的快排写法，区别都在于 partition
def partition(nums, l, r):
    pivot = nums[l]
    while l &lt; r:
        while l &lt; r and nums[r] &gt; pivot:
            r -= 1
        nums[l] = nums[r]
        while l &lt; r and nums[l] &lt;= pivot:
            l += 1
        nums[r] = nums[l]
    nums[l] = pivot
    return l

# 分治，递归
def q_sort(nums, l, r):
    if l &gt;= r:
        return
    pivot_idx = partition(nums, l, r)
    q_sort(nums, l, pivot_idx-1)
    q_sort(nums, pivot_idx+1, r)


def quick_sort(nums):
    q_sort(nums, 0, len(nums)-1)
</code></pre>
<h3 id="方法2交换">方法2：交换</h3>
<p>在方法1的思路上，修改为交换两个位置的元素</p>
<pre><code class="language-Python">def partition(nums, l, r):
    pivot = nums[l]
    start = l
    while l &lt; r:
        while l &lt; r and nums[r] &gt; pivot:
            r -= 1
        while l &lt; r and nums[l] &lt;= pivot:
            l += 1
        if l &lt; r:
            nums[l], nums[r] = nums[r], nums[l]
    nums[start], nums[l] = nums[l], nums[start]
    return l
</code></pre>
<h3 id="方法3区间维护">方法3：区间维护</h3>
<p>《算法导论》上面的写法：通过从左到右一次遍历，两个指针，比较并交换元素来维护区间 <code>[l, i]</code> 和 <code>(i, j)</code> 中的元素小于/大于 pivot</p>
<pre><code class="language-Python">def partition(nums, l, r):
    pivot = nums[r]
    i = l - 1
    for j in range(l, r):
        if nums[j] &lt;= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i+1], nums[r] = nums[r], nums[i+1]
    return i+1
</code></pre>
<p>其实还有一些其它的写法，不过大同小异，掌握核心思路就行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（08）]]></title>
        <id>https://Miaite.github.io/post/CvQvuRPWt/</id>
        <link href="https://Miaite.github.io/post/CvQvuRPWt/">
        </link>
        <updated>2020-11-19T08:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 49~55。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 49~55。</p>
<!-- more -->
<h2 id="term-49了解-new-handler-的行为">Term 49：了解 new-handler 的行为</h2>
<p>当 operator new 无法满足内存分配需求时，会抛出异常，且在此之前，会先调用用户设置的错误处理函数（即 new-handler）。通过 <code>std::set_new_handler</code> 可以设置 new-handler，要使其设计良好，需要满足以下条件：</p>
<ol>
<li>让更多内存可被使用</li>
<li>安装另一个 new-handler：设置调用另一个可能解决问题的 new-handler</li>
<li>卸除 new-handler：将 null 指针传给 set_new_handler。没有安装 new-handler 时 operator new 分配失败抛出异常</li>
<li>不返回：通常调用 abort 或 exit</li>
</ol>
<p>C++ 没有直接为 class 定制 new-handler 的语法，但我们仍然可以办到：</p>
<pre><code class="language-C++">template &lt;typename T&gt;
class NewHandlerSupport {  // mixin 风格的 base class，用以支持 class 专属的 set_new_handler
 public:
  static std::new_handler set_new_handler(std::new_handler) throw();
  static void* operator new(std::size_t size) throw(std::bad_alloc);

 private:
  static std::new_handler currentHandler;
};
template &lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw() {
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}
template &lt;typename T&gt;
void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc) {
  NewHandlerSupport h(std::set_new_handler(currentHandler));
  return ::operator new(size);
}
template &lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;  // 将 currentHandler 初始化为 null
// 使用方式如下
class Widget: public NewHandlerSupport&lt;Widget&gt; { ... } // 以自身类型继承这样一个模板类就足够
</code></pre>
<h2 id="term-50了解-new-和-delete-的合理替换时机">Term 50：了解 new 和 delete 的合理替换时机</h2>
<p>使用自定义的 operator new 和 operator delete 的合理使用场景：</p>
<ol>
<li>用来检测运用错误</li>
<li>收集动态分配内存的统计数据</li>
<li>增加分配和归还的速度</li>
<li>降低默认内存管理器带来的额外开销</li>
<li>实现内存地址对齐（alignment）</li>
<li>将相关的对象成簇集中，降低缺页中断的概率，因为它们很可能同时被调用</li>
<li>实现一些特定行为，例如在归还内存时将内容抹除</li>
</ol>
<h2 id="term-51编写-new-和-delete-时需固守常规">Term 51：编写 new 和 delete 时需固守常规</h2>
<p>operator new 分配成功时返回指针，不成功则调用 new-handler，可能会再尝试分配，所有的 new-handler 失败，则抛出 bad_alloc 异常。在设计自定义的 operator new 和 operator delete 过程中，需要注意：</p>
<ol>
<li>即使请求的是 0 byte， operator new 也要返回一个合法的指针，则可以简单地将 0 视为 1</li>
<li>operator new 应该内含无穷循环来实现上面那段话</li>
<li>class 专属版本的 operator new 应该处理错误大小的分配请求，比如被派生类继承之后，对派生类使用（基类的） new 会造成大小错误</li>
<li>operator delete 应该在收到 null 指针时不做任何事</li>
<li>class 专属版本的 operator delete 应该处理错误大小的分配请求</li>
</ol>
<h2 id="term-52写了-placement-new-也要写-placement-delete">Term 52：写了 placement new 也要写 placement delete</h2>
<ol>
<li>编写了 placement new 也要写 placement delete，否则可能会造成内存泄漏</li>
<li>声明  placement new 和 placement delete 时，要注意不要遮蔽了它们的正常版本</li>
</ol>
<h2 id="term-53不要轻忽编译器的警告">Term 53：不要轻忽编译器的警告</h2>
<ol>
<li>认真考虑编译器的警告</li>
<li>不同编译器针对相同代码的警告处理可能不一样</li>
</ol>
<h2 id="term-54让自己熟悉包括-tr1-在内的标准程序库">Term 54：让自己熟悉包括 TR1 在内的标准程序库</h2>
<p>如题。</p>
<h2 id="term-55让自己熟悉-boost">Term 55：让自己熟悉 Boost</h2>
<p>在 Modern C++ 的时代，Boost 的应用意义已经不如从前。但在熟悉标准程序库之后，Boost 仍是很好的学习对象，它包含了可能在未来会纳入标准程序库的一些东西。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（07）]]></title>
        <id>https://Miaite.github.io/post/sF-ehhx1o/</id>
        <link href="https://Miaite.github.io/post/sF-ehhx1o/">
        </link>
        <updated>2020-11-17T12:33:03.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 41~48。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 41~48。</p>
<!-- more -->
<h2 id="term-41了解隐式接口和编译期多态">Term 41：了解隐式接口和编译期多态</h2>
<ol>
<li>classes 和 templates 都支持接口和多态</li>
<li>对 classes 而言接口时显式的，以函数签名（函数名、参数类型、返回类型）为中心。多态则通过 virtual 函数发生与运行期</li>
<li>对 templates 参数而言，接口是隐式的，基于有效表达式。多态则是通过 template 具现化和函数重载解析发生与编译期</li>
</ol>
<h2 id="term-42了解-typename-的双重意义">Term 42：了解 typename 的双重意义</h2>
<ol>
<li>声明 template 参数时，前缀关键字 class 和 typename 同义</li>
<li>需要使用关键字 typename 标识嵌套从属类型名称；但不得在 base class lists（基类列）或 member initialization list 内以它作为 base class 修饰符</li>
</ol>
<pre><code class="language-C++">template &lt;typename C&gt;               // 可以使用 typename 或者 class
void f(const C&amp; container,          // 不能使用 typename
       typename C::iterator iter);  // 应该使用 typename

template &lt;typename T&gt;
class Drived : public Base&lt;T&gt;::Nested {  // 不使用 typename
 public:
  explicit Derived(int x) : Base&lt;T&gt;::Nested(x) {  // 不使用 typename
    typename Base&lt;T&gt;::Nested tmp;                 // 使用 typename
  }
};
</code></pre>
<h2 id="term-43学习处理模板化基类内的名称">Term 43：学习处理模板化基类内的名称</h2>
<p>派生类继承模板化基类的情况中，如果直接调用基类中的成员，会无法通过编译，因为编译器<strong>无法知道具体继承自哪个基类</strong>（假如基类被特化，可能根本不包含被调用的成员）。为了解决这个问题，有3种方法：</p>
<ol>
<li>使用 <code>this-&gt;</code></li>
<li>使用 <code>using</code></li>
<li>明确指明使用 base class 版本（不推荐，相当于关闭了 virtual）</li>
</ol>
<pre><code class="language-C++">template &lt;typename Company&gt;
class LoggingMsgSender: public MsgSender&lt;Company&gt; {  // MsgSender 中包含 sendClear() 函数
 public:
  using MsgSender&lt;Company&gt;::sendClear;  // 2.方法
  void sendClearMsg(const MsgInfo&amp; info) {
    sendClear(info);                      // 调用失败
    this-&gt;sendClear(info);                // 1.方法
    MsgSender&lt;Company&gt;::sendClear(info);  // 3.方法
  }
};
</code></pre>
<h2 id="term-44将与参数无关的代码抽离-template">Term 44：将与参数无关的代码抽离 template</h2>
<ol>
<li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可<strong>消除</strong>，做法是以函数参数或 class 成员变量替换 template 参数</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可<strong>降低</strong>，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码</li>
</ol>
<h2 id="term-45运用成员函数模板接受所有兼容类型">Term 45：运用成员函数模板接受所有兼容类型</h2>
<p>智能指针是很好用的东西，但是存在一个问题，其模板写法不能支持隐式的类型转换。真实的指针则可以做到，示例就是派生类指针可以隐式转换为基类指针。为了在使用智能指针时也能达到此效果，需要这样编写程序：</p>
<pre><code class="language-C++">template &lt;typename T&gt;
class SmartPtr {
 public:
  template &lt;typename U&gt;
  SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPrt(other.get()) { /*...*/ } // 支持隐式转换的 copy 构造函数模板
  T* get() const { return heldPtr; }  // 假设通用接口 get() 获取原始指针

 private:
  T* heldPtr;  // 原始指针
};
</code></pre>
<p>跟上面的操作一样，copy 赋值操作符也可以进行泛化。需注意，函数模板不会覆盖编译器自动生成的 copy 构造函数和copy 赋值操作符。</p>
<h2 id="term-46需要类型转换时请为模板定义非成员函数">Term 46：需要类型转换时请为模板定义非成员函数</h2>
<p>Term 24 提到应使用 non-member 函数对所有实参进行类型转换。在使用模板时，情况有一点变化，我们仍然应该编写一个 non-member 函数，然后再 class 中定义 friend 函数并调用外面的 non-member 函数。</p>
<pre><code class="language-C++">template &lt;typename T&gt; class Rational; // 声明类
template &lt;typename T&gt;
const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs); // 声明 helper

template &lt;typename T&gt;
class Rational {
 public:
  friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) { // 调用 helper
    return doMultiply(lhs, rhs);
  }
};

template &lt;typename T&gt;
const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) { ... } // 定义 helper
</code></pre>
<h2 id="term-47请使用-traits-classes-表现类型信息">Term 47：请使用 traits classes 表现类型信息</h2>
<ol>
<li>Traits classes 使得“类型相关信息”在编译器可用。它们以 templates 技术、typedef 表示类型和 “templates 特化”完成实现</li>
<li>Traits classes 通过重载，在编译器对类型执行 if...else 测试</li>
</ol>
<h2 id="term-48认识-template-元编程">Term 48：认识 template 元编程</h2>
<p>Template 元编程（TMP）是执行与编译器的过程，通过 template 产生更多源码。TMP 的贡献在于，将一些运行期的工作带到了编译期执行，通常会产生出更加高效的程序，并且在编译期就发现一些问题。TMP 单独来说已经是图灵完全机器，但是编写 TMP 代码会比“一般”C++ 难得多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（06）]]></title>
        <id>https://Miaite.github.io/post/N2VZ5x8wW/</id>
        <link href="https://Miaite.github.io/post/N2VZ5x8wW/">
        </link>
        <updated>2020-11-15T07:39:08.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
<!-- more -->
<h2 id="term-32确定你的-public-继承塑模出-is-a-关系">Term 32：确定你的 public 继承塑模出 is-a 关系</h2>
<p>public 继承意味着 is-a 关系。适用于 base classes 的每一件事情同样适用于 derived classes。</p>
<h2 id="term-33避免遮掩继承而来的名称">Term 33：避免遮掩继承而来的名称</h2>
<p>和局部/全局作用域类似，派生类/基类的成员也有这样的作用域覆盖关系。</p>
<ol>
<li>derived classes 内的名称会遮掩 base classes 内的名称（包括参数类型不同的函数）。在 public 继承下不应如此。</li>
<li>可以使用 <code>using</code> 声明式或者转交函数让被遮掩的名称恢复</li>
</ol>
<pre><code class="language-C++">class Base {
 public:
  virtual void mf1() = 0;
  virtual void mf1(int);
  void mf2();
  void mf2(double);
  ......
};
class Derived : public Base {
 public:
  using Base::mf1;  // 让 Base::mf1 可见
  virtual void mf1();
  void mf2() { Base::mf2(); };  // 实际调用了 Base::mf2()
  ......
};
......
Derived d;
int x;
double y;
d.mf1();   // 调用 Derived::mf1()
d.mf1(x);  // 调用 Base::mf1(int)
d.mf2();   // 调用了 Derived::mf2()，内部实际调用了 Base::mf2()
d.mf2(y);  // 不可行，被遮蔽
</code></pre>
<h2 id="term-34区分接口继承和实现继承">Term 34：区分接口继承和实现继承</h2>
<ol>
<li>接口继承和实现继承是不同的，在 public 继承下，derived classes 总是继承 base classes 的接口</li>
<li>pure virtual 函数继承接口</li>
<li>impure virtual 函数继承接口和缺省实现</li>
<li>non-virtual 函数继承接口和强制实现，不应该在 derived classes 中 override</li>
</ol>
<h2 id="term-35考虑-virtual-函数以外的其它选择">Term 35：考虑 virtual 函数以外的其它选择</h2>
<p>利用 virtual 函数去实现某些功能可能并非最佳选择，可以考虑一些其它的办法：</p>
<ol>
<li>使用 non-virtual interface(NVI) 手法，以 public non-virtual 成员函数包裹访问性较低的（private） virtual 函数，这是 <strong>Template Method</strong> 设计模式的一种特殊形式</li>
<li>将 virtual 函数替换为“函数指针成员变量”，这是 <strong>Stratege</strong> 设计模式的一种分解形式</li>
<li>进一步，将 2. 中的函数指针替换为 <code>tr1::function</code>，则只要能兼容相应的参数的可调用对象都可以被应用上</li>
<li>对于 3. 中的可调用对象，可以以（继承的）类去实现，相当于抽取出 virtual 函数的功能，在另一个类中实现</li>
<li>2./3./4. 带来的缺点是，无法访问 non-public 成员</li>
</ol>
<h2 id="term-36绝不重新定义继承而来的-non-virtual-函数">Term 36：绝不重新定义继承而来的 non-virtual 函数</h2>
<p>这样会造成一些混乱，比如，以一个基类指针指向派生类对象时，调用的 non-virtual 函数会是基类的版本。原因在于静态绑定。</p>
<h2 id="term-37绝不重新定义继承而来的缺省参数值">Term 37：绝不重新定义继承而来的缺省参数值</h2>
<p>不要重新定义继承而来的缺省参数值，它是静态绑定，而 virtual 函数是动态绑定。</p>
<h2 id="term-38通过复合塑模出-has-a-或者根据某物实现出">Term 38：通过复合塑模出 has-a 或者“根据某物实现出”</h2>
<p>对于 has-a 或者“根据某物实现出”的情况，需要做的不是继承，而是在自己编写的类中使用需要用到的类的对象。</p>
<h2 id="term-39明智而审慎地使用-private-继承">Term 39：明智而审慎地使用 private 继承</h2>
<ol>
<li>private 继承意味着“根据某物实现出”这种情况，它通常比复合级别低，在需要访问 protect成员或者需要 override virtual 函数时，这样的设计时合理的</li>
<li>private 继承在大多数编译器中可以实现 empty base optimization，这对空间敏感的开发任务有效</li>
</ol>
<h2 id="term-40明智而审慎地使用多重继承">Term 40：明智而审慎地使用多重继承</h2>
<ol>
<li>多重继承可能导致歧义性，以及对 virtual 继承的需要</li>
<li>virtual 继承会增加各方面成本，最佳情况时不带任何数据</li>
<li>多重继承在某些情况确实有用，比如 public 继承一个接口 class，同时 private 继承一个实现 class</li>
<li>尽量不要使用多重继承</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（05）]]></title>
        <id>https://Miaite.github.io/post/Lxmd6dG5E/</id>
        <link href="https://Miaite.github.io/post/Lxmd6dG5E/">
        </link>
        <updated>2020-11-11T11:48:56.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
<!-- more -->
<h2 id="term-26尽可能延后变量定义式出现时间">Term 26：尽可能延后变量定义式出现时间</h2>
<p>定义一个变量（或者对象）对调用其构造函数，因此最好时在需要的时刻才去定义并初始化。至于只在循环内使用的变量通常定义在<strong>循环内</strong>，除非明确知道赋值比构造+析构更加高效而且确实有必要时，才将其定义在循环外。</p>
<h2 id="term-27尽量少做转型动作">Term 27：尽量少做转型动作</h2>
<ol>
<li>如果可以，尽量避免转型，特别是避免低效的 dynamic_casts，优先尝试其它的解决方案</li>
<li>如果转型是必要的，试着将它隐藏与函数之中</li>
<li>不要使用 C 风格的转型</li>
</ol>
<h2 id="term-28避免返回-handles-指向对象内部成分">Term 28：避免返回 handles 指向对象内部成分</h2>
<p>避免返回 handles（包括指针、引用、迭代器）指向对象内部成分。这样可以增加封装性，并且避免 handle 在对象被销毁后指向空。</p>
<h2 id="term-29为异常安全而努力是值得的">Term 29：为“异常安全”而努力是值得的</h2>
<ol>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏</li>
<li>异常安全函数三种保证：基本型（保证程序有效）、强烈型（保证程序回到之前的状态）、不抛异常型</li>
<li>强烈保证往往能够以 copy-and-swap 实现出来，但强烈保证并非对所有函数都可以实现或具备现实意义</li>
<li>函数提供的异常安全保证通常等于其所调用的函数中异常安全保证最弱的那个（木桶效应）</li>
</ol>
<h2 id="term-30透彻了解-inlining-的里里外外">Term 30：透彻了解 inlining 的里里外外</h2>
<p>inline 是编译器可选的操作，实际取决于具体编译器的平台和版本等。</p>
<ol>
<li>定义于 class 内的函数是一种隐式 inline 请求</li>
<li>inline 应当用于小型的、调用频繁的函数，避免代码膨胀，使调试和程序升级的过程也变得更加容易</li>
</ol>
<h2 id="term-31将文件间的编译依存关系降至最低">Term 31：将文件间的编译依存关系降至最低</h2>
<p>降低文件间的编译依存关系有助于减少编译的工作量</p>
<ol>
<li>支持“编译依存性最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（04）]]></title>
        <id>https://Miaite.github.io/post/gbhU7f2k5/</id>
        <link href="https://Miaite.github.io/post/gbhU7f2k5/">
        </link>
        <updated>2020-11-10T06:29:15.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
<!-- more -->
<h2 id="term-18让接口容易被正确使用不易被误用">Term 18：让接口容易被正确使用，不易被误用</h2>
<p>这一点其实比较难做到，可以参考这几个方面：</p>
<ol>
<li>接口的一致性，与内置类型（包括 STL）的行为兼容</li>
<li>防止误用包括建立新类型、限制类型上的操作、束缚对象的值以及自动管理资源</li>
<li>shared_ptr 支持定制型 deleter，可以防范 DLL 问题，可用来自动解除互斥锁</li>
</ol>
<h2 id="term-19设计-class-犹如设计-type">Term 19：设计 class 犹如设计 type</h2>
<p>在 C++ 中，设计一个通用的 class 就是设计一个新的类型，需要考虑以下一些方面：</p>
<ol>
<li>新 type 的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？调用不同的函数</li>
<li>新 type 的对象如果被 passed by value，意味着什么？会调用 copy 构造函数</li>
<li>什么是新 type 的合法值？</li>
<li>你的新 type 需要配合某个继承图系吗？继承自某个 class 或者允许被继承有不同的设计要点</li>
<li>你的新 type 需要什么样的转换？考虑是否需要在不同的 class 对象之间转换，设计显式/隐式转换</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？禁用编译器自动生成的函数</li>
<li>谁该取用新 type 的成员？考虑如何设置 public/protect/private 成员以及 friends</li>
<li>什么是新 type 的 undeclared interface？</li>
<li>你的新 type 有多么一般化？考虑定义一个新的 class template</li>
<li>你真的需要一个新 type 吗？也许通过多个函数或者 template 就能达到需要</li>
</ol>
<h2 id="term-20宁以-pass-by-reference-const-替换-pass-by-value">Term 20：宁以 pass-by-reference-const 替换 pass-by-value</h2>
<p>C++ 默认以 value 形式进行传递，这会带来大量的复制消耗，而且可能造成对象切割（slicing）问题。以 reference 传递会高效很多。但也有例外，内置类型、STL 迭代器以及函数对象以 value 传递更加合适。</p>
<h2 id="term-21必须返回对象时别妄想返回器-reference">Term 21：必须返回对象时，别妄想返回器 reference</h2>
<p>返回 pointer/reference 指向 local 对象是错误行为，指向 local static 也是愚蠢的行为（但可行），reference 指向 heap-allocated 对象会内存泄漏。</p>
<h2 id="term-22将成员变量声明为-private">Term 22：将成员变量声明为 private</h2>
<p>简单来说，就是为了提高 class 的封装性</p>
<h2 id="term-23宁以-non-menber-non-friend-替换-member-函数">Term 23：宁以 non-menber、non-friend 替换 member 函数</h2>
<p>这样既可以增加 class 的封装性，也可以让函数更容易扩充。</p>
<h2 id="term-24若所有参数皆需类型转换请为此采用-non-menber-函数">Term 24：若所有参数皆需类型转换，请为此采用 non-menber 函数</h2>
<p>采用 non-menber 函数可以进行合适的隐式类型转换。</p>
<h2 id="term-25考虑写出一个不抛出异常的-swap-函数">Term 25：考虑写出一个不抛出异常的 swap 函数</h2>
<p>STL 中默认的 swap 函数会调用 copy 构造函数和 copy 赋值运算符，在某些情况下带来不必要的性能损耗。可以考虑的改写思路：</p>
<ol>
<li>添加一个用于 swap 的 public member 函数（不能抛出异常）</li>
<li>在 class 或者 template 的命名空间提供一个 non-member 函数 swap，用这个函数调用 1. 中的 member 函数 swap。这点可适用于 class template</li>
<li>特化 std::swap 来调用 member 函数 swap</li>
<li>用户使用 swap 时应当使用 <code>using std::swap;</code></li>
</ol>
<pre><code class="language-C++">template&lt;typename T&gt;
void doSomething(T&amp; obj1, T&amp; obj2){
    using std::swap;    // 让 std::swap 在此函数内可见
    swap(obj1, obj2);    // 自动选择最佳的 swap 版本
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/386I6Xacv/</id>
        <link href="https://Miaite.github.io/post/386I6Xacv/">
        </link>
        <updated>2020-11-07T07:42:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
<!-- more -->
<h2 id="term-13以对象管理资源">Term 13：以对象管理资源</h2>
<p>编写 C++ 程序容易遇到的一个问题就是内存泄漏，手动 <code>delete</code> 容易遇到各种问题。一个较好的解决方案是使用类来管理资源，通过析构过程保证资源的正确释放。</p>
<ol>
<li>使用 RAII 对象，在其构造函数中获取资源，析构函数中释放资源</li>
<li>常用的 RAII 对象，智能指针，shared_ptr 和 unique_ptr</li>
</ol>
<h2 id="term-14在资源管理类中小心-copying-行为">Term 14：在资源管理类中小心 copying 行为</h2>
<p>可选的策略有：</p>
<ol>
<li>禁止复制</li>
<li>引用计数</li>
<li>深拷贝</li>
<li>转移所有权（auto_ptr 那样的行为）</li>
</ol>
<h2 id="term-15在资源管理类中提供对原始资源的访问">Term 15：在资源管理类中提供对原始资源的访问</h2>
<p>RAII class 应当提供一个直接获取到原始资源（指针/引用）的方法。一般来说，显示转换比较安全，隐式转换比较方便。</p>
<h2 id="term-16成对使用-new-和-delete-时要采取相同形式">Term 16：成对使用 new 和 delete 时要采取相同形式</h2>
<p>如果在 <code>new</code> 时使用了 <code>[]</code>，那么在 <code>delete</code> 时也应使用 <code>[]</code>，未使用 <code>[]</code> 时同样要准寻这个原则，以避免释放资源出错。</p>
<h2 id="term-17以独立语句将-newed-对象置入智能指针">Term 17：以独立语句将 newed 对象置入智能指针</h2>
<p>要以独立语句将 newed 对象置入智能指针，否则可能发生难以察觉的资源泄漏</p>
<pre><code class="language-C++">// 首先有以下定义
int priority();
void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);
// 几种调用
processWidget(new Widget, priority());    // 出错，shared_ptr 无法隐式转换
processWidget(std::tr1::shared_ptr&lt;Widget&gt; (new Widget), priority());    // 虽然可以通过编译，但是假如 priority() 先于 shared_ptr 的构造函数执行且出现异常，则资源泄漏
// 下面时正确做法
std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);
processWidget(pw, priority());
</code></pre>
]]></content>
    </entry>
</feed>