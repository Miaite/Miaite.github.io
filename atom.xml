<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2020-11-03T11:27:11.599Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些杂物，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[Effective C++笔记（01）]]></title>
        <id>https://Miaite.github.io/post/UyR9S6D5b/</id>
        <link href="https://Miaite.github.io/post/UyR9S6D5b/">
        </link>
        <updated>2020-11-03T11:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 1~4。</p>
]]></summary>
        <content type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 1~4。</p>
<!-- more -->
<h2 id="term-1视-c-为一个语言联邦">Term 1：视 C++ 为一个语言联邦</h2>
<p>这一点说起来容易（做起来难）。简单讲，C++ 的语言设计其实有四个部分 ：（兼容）C、面向对象、泛型和模板、STL，这四个部分相互关联却又在设计思想上相对独立。每一个部分都会有一些不同的准则，在 C 中的常用思路不一定适合在泛型和模板中使用。</p>
<p>一般来说，泛型和模板这一部分是 C++ 程序员最薄弱的，需要特别注意。</p>
<h2 id="term-2尽量以-const-enum-inline-替换-define">Term 2：尽量以 const, enum, inline 替换 #define</h2>
<ol>
<li>对于常量，使用 const 或者 enum hack 代替</li>
<li>对于形似函数的宏定义，使用 inline 函数代替（可能会用到模板）</li>
</ol>
<pre><code>enum hack 的例子：
class Game {
    private:
        static const int GameTurn = 10;
        int scores[GameTurn];
};    //不支持类内初始化的编译器报错
class GamePlayer{
    private:
        enum {NumTurns = 5};

        int scores[NumTurns];
        ...
};    //不支持类内初始化的编译器也能编译通过
</code></pre>
<h2 id="term-3尽可能使用-const">Term 3：尽可能使用 const</h2>
<ol>
<li>const 和指针：记住 <code>const</code> 出现在 <code>*</code> 左边，表示被指物是常量；如果出现在 <code>*</code> 右边，表示指针自身是常量；如果出现在 <code>*</code> 两边，表示被指物和指针都是常量</li>
<li>STL 的迭代器可以视为指针，<code>const std::vector&lt;int&gt;::iterator iter</code> 效果等同于 <code>T* const</code>，<code>std::vector&lt;int&gt;::const_iterator cIter</code> 效果等同于 <code>const T*</code></li>
<li>设置函数返回对象为 const 可以排除一些不必要的安全隐患</li>
<li>类的成员函数可以通过（函数名之后，函数体之前的那个） <code>const</code> 重载，分别针对 const/non-const 对象</li>
<li>bitwise const 和 logical const 的区别，通过 <code>mutable</code> 实现 logical const</li>
<li>当成员函数的 const/non-const 版本有同样的实现时，可以将实现代码写在 const 版本中，而在 non-const 版本中调用即可，但是需要注意<strong>转换类型</strong>，并且一定要小心，避免安全隐患。</li>
</ol>
<pre><code>class TextBlock {
 public:
  const char&amp; operator[](std::size_t position) const { return text[position]; }
  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);
  }
  // ......
};
</code></pre>
<h2 id="term-4确定对象被使用前已被初始化">Term 4：确定对象被使用前已被初始化</h2>
<ol>
<li>手动初始化内置型对象，比如 <code>int i = 0;</code></li>
<li>构造函数使用成员初值表进行初始化</li>
<li>为免除“跨编译单元初始化顺序不确定”问题，使用 local static 对象替换 static 对象</li>
</ol>
]]></content>
    </entry>
</feed>