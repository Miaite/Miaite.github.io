<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Miaite.github.io</id>
    <title>A Blog of Miaite</title>
    <updated>2020-11-15T07:39:58.466Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Miaite.github.io"/>
    <link rel="self" href="https://Miaite.github.io/atom.xml"/>
    <subtitle>一些流水账，技术笔记为主</subtitle>
    <logo>https://Miaite.github.io/images/avatar.png</logo>
    <icon>https://Miaite.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, A Blog of Miaite</rights>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（06）]]></title>
        <id>https://Miaite.github.io/post/N2VZ5x8wW/</id>
        <link href="https://Miaite.github.io/post/N2VZ5x8wW/">
        </link>
        <updated>2020-11-15T07:39:08.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 32~40。</p>
<!-- more -->
<h2 id="term-32确定你的-public-继承塑模出-is-a-关系">Term 32：确定你的 public 继承塑模出 is-a 关系</h2>
<p>public 继承意味着 is-a 关系。适用于 base classes 的每一件事情同样适用于 derived classes。</p>
<h2 id="term-33避免遮掩继承而来的名称">Term 33：避免遮掩继承而来的名称</h2>
<p>和局部/全局作用域类似，派生类/基类的成员也有这样的作用域覆盖关系。</p>
<ol>
<li>derived classes 内的名称会遮掩 base classes 内的名称（包括参数类型不同的函数）。在 public 继承下不应如此。</li>
<li>可以使用 <code>using</code> 声明式或者转交函数让被遮掩的名称恢复</li>
</ol>
<pre><code>class Base {
 public:
  virtual void mf1() = 0;
  virtual void mf1(int);
  void mf2();
  void mf2(double);
  ......
};
class Derived : public Base {
 public:
  using Base::mf1;  // 让 Base::mf1 可见
  virtual void mf1();
  void mf2() { Base::mf2(); };  // 实际调用了 Base::mf2()
  ......
};
......
Derived d;
int x;
double y;
d.mf1();   // 调用 Derived::mf1()
d.mf1(x);  // 调用 Base::mf1(int)
d.mf2();   // 调用了 Derived::mf2()，内部实际调用了 Base::mf2()
d.mf2(y);  // 不可行，被遮蔽
</code></pre>
<h2 id="term-34区分接口继承和实现继承">Term 34：区分接口继承和实现继承</h2>
<ol>
<li>接口继承和实现继承是不同的，在 public 继承下，derived classes 总是继承 base classes 的接口</li>
<li>pure virtual 函数继承接口</li>
<li>impure virtual 函数继承接口和缺省实现</li>
<li>non-virtual 函数继承接口和强制实现，不应该在 derived classes 中 override</li>
</ol>
<h2 id="term-35考虑-virtual-函数以外的其它选择">Term 35：考虑 virtual 函数以外的其它选择</h2>
<p>利用 virtual 函数去实现某些功能可能并非最佳选择，可以考虑一些其它的办法：</p>
<ol>
<li>使用 non-virtual interface(NVI) 手法，以 public non-virtual 成员函数包裹访问性较低的（private） virtual 函数，这是 <strong>Template Method</strong> 设计模式的一种特殊形式</li>
<li>将 virtual 函数替换为“函数指针成员变量”，这是 <strong>Stratege</strong> 设计模式的一种分解形式</li>
<li>进一步，将 2. 中的函数指针替换为 <code>tr1::function</code>，则只要能兼容相应的参数的可调用对象都可以被应用上</li>
<li>对于 3. 中的可调用对象，可以以（继承的）类去实现，相当于抽取出 virtual 函数的功能，在另一个类中实现</li>
<li>2./3./4. 带来的缺点是，无法访问 non-public 成员</li>
</ol>
<h2 id="term-36绝不重新定义继承而来的-non-virtual-函数">Term 36：绝不重新定义继承而来的 non-virtual 函数</h2>
<p>这样会造成一些混乱，比如，以一个基类指针指向派生类对象时，调用的 non-virtual 函数会是基类的版本。原因在于静态绑定。</p>
<h2 id="term-37绝不重新定义继承而来的缺省参数值">Term 37：绝不重新定义继承而来的缺省参数值</h2>
<p>不要重新定义继承而来的缺省参数值，它是静态绑定，而 virtual 函数是动态绑定。</p>
<h2 id="term-38通过复合塑模出-has-a-或者根据某物实现出">Term 38：通过复合塑模出 has-a 或者“根据某物实现出”</h2>
<p>对于 has-a 或者“根据某物实现出”的情况，需要做的不是继承，而是在自己编写的类中使用需要用到的类的对象。</p>
<h2 id="term-39明智而审慎地使用-private-继承">Term 39：明智而审慎地使用 private 继承</h2>
<ol>
<li>private 继承意味着“根据某物实现出”这种情况，它通常比复合级别低，在需要访问 protect成员或者需要 override virtual 函数时，这样的设计时合理的</li>
<li>private 继承在大多数编译器中可以实现 empty base optimization，这对空间敏感的开发任务有效</li>
</ol>
<h2 id="term-40明智而审慎地使用多重继承">Term 40：明智而审慎地使用多重继承</h2>
<ol>
<li>多重继承可能导致歧义性，以及对 virtual 继承的需要</li>
<li>virtual 继承会增加各方面成本，最佳情况时不带任何数据</li>
<li>多重继承在某些情况确实有用，比如 public 继承一个接口 class，同时 private 继承一个实现 class</li>
<li>尽量不要使用多重继承</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（05）]]></title>
        <id>https://Miaite.github.io/post/Lxmd6dG5E/</id>
        <link href="https://Miaite.github.io/post/Lxmd6dG5E/">
        </link>
        <updated>2020-11-11T11:48:56.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 26~31。</p>
<!-- more -->
<h2 id="term-26尽可能延后变量定义式出现时间">Term 26：尽可能延后变量定义式出现时间</h2>
<p>定义一个变量（或者对象）对调用其构造函数，因此最好时在需要的时刻才去定义并初始化。至于只在循环内使用的变量通常定义在<strong>循环内</strong>，除非明确知道赋值比构造+析构更加高效而且确实有必要时，才将其定义在循环外。</p>
<h2 id="term-27尽量少做转型动作">Term 27：尽量少做转型动作</h2>
<ol>
<li>如果可以，尽量避免转型，特别是避免低效的 dynamic_casts，优先尝试其它的解决方案</li>
<li>如果转型是必要的，试着将它隐藏与函数之中</li>
<li>不要使用 C 风格的转型</li>
</ol>
<h2 id="term-28避免返回-handles-指向对象内部成分">Term 28：避免返回 handles 指向对象内部成分</h2>
<p>避免返回 handles（包括指针、引用、迭代器）指向对象内部成分。这样可以增加封装性，并且避免 handle 在对象被销毁后指向空。</p>
<h2 id="term-29为异常安全而努力是值得的">Term 29：为“异常安全”而努力是值得的</h2>
<ol>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏</li>
<li>异常安全函数三种保证：基本型（保证程序有效）、强烈型（保证程序回到之前的状态）、不抛异常型</li>
<li>强烈保证往往能够以 copy-and-swap 实现出来，但强烈保证并非对所有函数都可以实现或具备现实意义</li>
<li>函数提供的异常安全保证通常等于其所调用的函数中异常安全保证最弱的那个（木桶效应）</li>
</ol>
<h2 id="term-30透彻了解-inlining-的里里外外">Term 30：透彻了解 inlining 的里里外外</h2>
<p>inline 是编译器可选的操作，实际取决于具体编译器的平台和版本等。</p>
<ol>
<li>定义于 class 内的函数是一种隐式 inline 请求</li>
<li>inline 应当用于小型的、调用频繁的函数，避免代码膨胀，使调试和程序升级的过程也变得更加容易</li>
</ol>
<h2 id="term-31将文件间的编译依存关系降至最低">Term 31：将文件间的编译依存关系降至最低</h2>
<p>降低文件间的编译依存关系有助于减少编译的工作量</p>
<ol>
<li>支持“编译依存性最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（04）]]></title>
        <id>https://Miaite.github.io/post/gbhU7f2k5/</id>
        <link href="https://Miaite.github.io/post/gbhU7f2k5/">
        </link>
        <updated>2020-11-10T06:29:15.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 18~25。</p>
<!-- more -->
<h2 id="term-18让接口容易被正确使用不易被误用">Term 18：让接口容易被正确使用，不易被误用</h2>
<p>这一点其实比较难做到，可以参考这几个方面：</p>
<ol>
<li>接口的一致性，与内置类型（包括 STL）的行为兼容</li>
<li>防止误用包括建立新类型、限制类型上的操作、束缚对象的值以及自动管理资源</li>
<li>shared_ptr 支持定制型 deleter，可以防范 DLL 问题，可用来自动解除互斥锁</li>
</ol>
<h2 id="term-19设计-class-犹如设计-type">Term 19：设计 class 犹如设计 type</h2>
<p>在 C++ 中，设计一个通用的 class 就是设计一个新的类型，需要考虑以下一些方面：</p>
<ol>
<li>新 type 的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？调用不同的函数</li>
<li>新 type 的对象如果被 passed by value，意味着什么？会调用 copy 构造函数</li>
<li>什么是新 type 的合法值？</li>
<li>你的新 type 需要配合某个继承图系吗？继承自某个 class 或者允许被继承有不同的设计要点</li>
<li>你的新 type 需要什么样的转换？考虑是否需要在不同的 class 对象之间转换，设计显式/隐式转换</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？禁用编译器自动生成的函数</li>
<li>谁该取用新 type 的成员？考虑如何设置 public/protect/private 成员以及 friends</li>
<li>什么是新 type 的 undeclared interface？</li>
<li>你的新 type 有多么一般化？考虑定义一个新的 class template</li>
<li>你真的需要一个新 type 吗？也许通过多个函数或者 template 就能达到需要</li>
</ol>
<h2 id="term-20宁以-pass-by-reference-const-替换-pass-by-value">Term 20：宁以 pass-by-reference-const 替换 pass-by-value</h2>
<p>C++ 默认以 value 形式进行传递，这会带来大量的复制消耗，而且可能造成对象切割（slicing）问题。以 reference 传递会高效很多。但也有例外，内置类型、STL 迭代器以及函数对象以 value 传递更加合适。</p>
<h2 id="term-21必须返回对象时别妄想返回器-reference">Term 21：必须返回对象时，别妄想返回器 reference</h2>
<p>返回 pointer/reference 指向 local 对象是错误行为，指向 local static 也是愚蠢的行为（但可行），reference 指向 heap-allocated 对象会内存泄漏。</p>
<h2 id="term-22将成员变量声明为-private">Term 22：将成员变量声明为 private</h2>
<p>简单来说，就是为了提高 class 的封装性</p>
<h2 id="term-23宁以-non-menber-non-friend-替换-member-函数">Term 23：宁以 non-menber、non-friend 替换 member 函数</h2>
<p>这样既可以增加 class 的封装性，也可以让函数更容易扩充。</p>
<h2 id="term-24若所有参数皆需类型转换请为此采用-non-menber-函数">Term 24：若所有参数皆需类型转换，请为此采用 non-menber 函数</h2>
<p>采用 non-menber 函数可以进行合适的隐式类型转换。</p>
<h2 id="term-25考虑写出一个不抛出异常的-swap-函数">Term 25：考虑写出一个不抛出异常的 swap 函数</h2>
<p>STL 中默认的 swap 函数会调用 copy 构造函数和 copy 赋值运算符，在某些情况下带来不必要的性能损耗。可以考虑的改写思路：</p>
<ol>
<li>添加一个用于 swap 的 public member 函数（不能抛出异常）</li>
<li>在 class 或者 template 的命名空间提供一个 non-member 函数 swap，用这个函数调用 1. 中的 member 函数 swap。这点可适用于 class template</li>
<li>特化 std::swap 来调用 member 函数 swap</li>
<li>用户使用 swap 时应当使用 <code>using std::swap;</code></li>
</ol>
<pre><code>template&lt;typename T&gt;
void doSomething(T&amp; obj1, T&amp; obj2){
    using std::swap;    // 让 std::swap 在此函数内可见
    swap(obj1, obj2);    // 自动选择最佳的 swap 版本
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（03）]]></title>
        <id>https://Miaite.github.io/post/386I6Xacv/</id>
        <link href="https://Miaite.github.io/post/386I6Xacv/">
        </link>
        <updated>2020-11-07T07:42:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 13~17。</p>
<!-- more -->
<h2 id="term-13以对象管理资源">Term 13：以对象管理资源</h2>
<p>编写 C++ 程序容易遇到的一个问题就是内存泄漏，手动 <code>delete</code> 容易遇到各种问题。一个较好的解决方案是使用类来管理资源，通过析构过程保证资源的正确释放。</p>
<ol>
<li>使用 RAII 对象，在其构造函数中获取资源，析构函数中释放资源</li>
<li>常用的 RAII 对象，智能指针，shared_ptr 和 unique_ptr</li>
</ol>
<h2 id="term-14在资源管理类中小心-copying-行为">Term 14：在资源管理类中小心 copying 行为</h2>
<p>可选的策略有：</p>
<ol>
<li>禁止复制</li>
<li>引用计数</li>
<li>深拷贝</li>
<li>转移所有权（auto_ptr 那样的行为）</li>
</ol>
<h2 id="term-15在资源管理类中提供对原始资源的访问">Term 15：在资源管理类中提供对原始资源的访问</h2>
<p>RAII class 应当提供一个直接获取到原始资源（指针/引用）的方法。一般来说，显示转换比较安全，隐式转换比较方便。</p>
<h2 id="term-16成对使用-new-和-delete-时要采取相同形式">Term 16：成对使用 new 和 delete 时要采取相同形式</h2>
<p>如果在 <code>new</code> 时使用了 <code>[]</code>，那么在 <code>delete</code> 时也应使用 <code>[]</code>，未使用 <code>[]</code> 时同样要准寻这个原则，以避免释放资源出错。</p>
<h2 id="term-17以独立语句将-newed-对象置入智能指针">Term 17：以独立语句将 newed 对象置入智能指针</h2>
<p>要以独立语句将 newed 对象置入智能指针，否则可能发生难以察觉的资源泄漏</p>
<pre><code>// 首先有以下定义
int priority();
void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);
// 几种调用
processWidget(new Widget, priority());    // 出错，shared_ptr 无法隐式转换
processWidget(std::tr1::shared_ptr&lt;Widget&gt; (new Widget), priority());    // 虽然可以通过编译，但是假如 priority() 先于 shared_ptr 的构造函数执行且出现异常，则资源泄漏
// 下面时正确做法
std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);
processWidget(pw, priority());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（02）]]></title>
        <id>https://Miaite.github.io/post/ol7D4iZKg/</id>
        <link href="https://Miaite.github.io/post/ol7D4iZKg/">
        </link>
        <updated>2020-11-05T11:45:07.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇笔记包含 Term 05~12。</p>
<!-- more -->
<h2 id="term-05了解-c-默默编写并调用了哪些函数">Term 05：了解 C++ 默默编写并调用了哪些函数</h2>
<p>编译器会为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符以及析构函数，它们都是 public 以及 inline 的。注意到，当 copy assignment 操作符在父类中被声明为 private 或者含有 const 成员面对等情况，编译器不会自动创建 copy assignment 操作符；编译器自动创建的析构函数不是虚函数，除非继承自虚函数。</p>
<h2 id="term-06若不想使用编译器自动生成的函数就应该明确拒绝">Term 06：若不想使用编译器自动生成的函数，就应该明确拒绝</h2>
<p>通过 Term 05 我们知道编译器会自动生成一些成员函数，但有时我们可能不需要这种功能。解决方法：</p>
<ol>
<li>将该成员函数声明为 private 并且不予实现</li>
<li>按照 1. 构建一个基类，然后去继承它</li>
<li>使用 C++(11) 提供的 <code>=default</code> 和 <code>=delete</code> 显式启用或者禁用编译器自动版本的函数</li>
</ol>
<h2 id="term-07为多态基类声明-virtual-析构函数">Term 07：为多态基类声明 virtual 析构函数</h2>
<ol>
<li>用作多态的基类应该声明 virtual 析构函数。如果 class 带有 virtual 成员函数，应该声明 virtual 析构函数</li>
<li>不是基类或者不是用作多态的基类，不应该声明 virtual 析构函数，比如 STL 容器</li>
<li>以上两点可以避免内存泄漏</li>
</ol>
<h2 id="term-08别让异常逃离析构函数">Term 08：别让异常逃离析构函数</h2>
<p>不应该在析构函数内抛出异常，保证析构函数能执行。将可能造成异常的部分移到另一个函数内或者交给用户自己处理。在 C++(11) 中，可以使用 <code>noexcept</code> 来限制函数，如果出现异常会直接终止程序。</p>
<h2 id="term-09绝不在构造和析构过程中调用-virtual-函数">Term 09：绝不在构造和析构过程中调用 virtual 函数</h2>
<p>如果在 base class 构造和析构过程中调用 virtual 函数，该函数的版本是 base class 对应的版本，不会是意图的 derived class 版本。</p>
<h2 id="term-10令-operator-返回一个-reference-to-this">Term 10：令 operator= 返回一个 reference to *this</h2>
<p>可以实现右结合的连锁赋值，大家都这么做，一种习惯性接口。</p>
<h2 id="term-11在-operator-中处理自我赋值">Term 11：在 operator= 中处理“自我赋值”</h2>
<ol>
<li>如果将一个对象赋值给自身，会造成安全问题。处理方法可以是：通过地址判断是否是同一对象；安排安全的语句顺序；copy-and-swap</li>
<li>任何函数，如果操作多个对象，要考虑其中某些对象其实是同一个这种情况</li>
</ol>
<h2 id="term-12复制对象时勿忘每一个成分">Term 12：复制对象时勿忘每一个成分</h2>
<ol>
<li>copy 构造函数和 copy 赋值操作符会执行拷贝</li>
<li>拷贝对象时应该把每个成员变量都考虑到，并且调用对应的 base class 的函数</li>
<li>copy 构造函数和 copy 赋值操作符之间<strong>不能</strong>互相调用，可以考虑新创建一个成员函数维护冗余代码，然后在 copy 操作时调用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++ 笔记（01）]]></title>
        <id>https://Miaite.github.io/post/UyR9S6D5b/</id>
        <link href="https://Miaite.github.io/post/UyR9S6D5b/">
        </link>
        <updated>2020-11-03T11:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
]]></summary>
        <content type="html"><![CDATA[<p>就学习难度而言，C++是一门臭名昭著的编程语言。《Effective C++》总结了 55 条 C++(98/03)的开发准则，供开发者学习参考。本篇笔记包含 Term 01~04，我也依据 Modern C++ 的改变，对其中某些细节进行了修订。</p>
<!-- more -->
<h2 id="term-01视-c-为一个语言联邦">Term 01：视 C++ 为一个语言联邦</h2>
<p>这一点说起来容易（做起来难）。简单讲，C++ 的语言设计其实有四个部分 ：（兼容）C、面向对象、泛型和模板、STL，这四个部分相互关联却又在设计思想上相对独立。每一个部分都会有一些不同的准则，在 C 中的常用思路不一定适合在泛型和模板中使用。</p>
<p>一般来说，泛型和模板这一部分是 C++ 程序员最薄弱的，需要特别注意。</p>
<h2 id="term-02尽量以-const-enum-inline-替换-define">Term 02：尽量以 const, enum, inline 替换 #define</h2>
<ol>
<li>对于常量，使用 const 或者 enum hack 代替</li>
<li>对于形似函数的宏定义，使用 inline 函数代替（可能会用到模板）</li>
</ol>
<pre><code>// enum hack 的例子：
class Game {
    private:
        static const int GameTurn = 10;
        int scores[GameTurn];
};    //不支持类内初始化的编译器报错
class GamePlayer{
    private:
        enum {NumTurns = 5};
        int scores[NumTurns];
};    //不支持类内初始化的编译器也能编译通过
</code></pre>
<h2 id="term-03尽可能使用-const">Term 03：尽可能使用 const</h2>
<ol>
<li>const 和指针：记住 <code>const</code> 出现在 <code>*</code> 左边，表示被指物是常量；如果出现在 <code>*</code> 右边，表示指针自身是常量；如果出现在 <code>*</code> 两边，表示被指物和指针都是常量</li>
<li>STL 的迭代器可以视为指针，<code>const std::vector&lt;int&gt;::iterator iter</code> 效果等同于 <code>T* const</code>，<code>std::vector&lt;int&gt;::const_iterator cIter</code> 效果等同于 <code>const T*</code></li>
<li>设置函数返回对象为 const 可以排除一些不必要的安全隐患</li>
<li>类的成员函数可以通过（函数名之后，函数体之前的那个） <code>const</code> 重载，分别针对 const/non-const 对象</li>
<li>bitwise const 和 logical const 的区别，通过 <code>mutable</code> 实现 logical const</li>
<li>当成员函数的 const/non-const 版本有同样的实现时，可以将实现代码写在 const 版本中，而在 non-const 版本中调用即可，但是需要注意<strong>转换类型</strong>，并且一定要小心，避免安全隐患。</li>
</ol>
<pre><code>class TextBlock {
 public:
  const char&amp; operator[](std::size_t position) const { return text[position]; }
  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);
  }
  // ......
};
</code></pre>
<h2 id="term-04确定对象被使用前已被初始化">Term 04：确定对象被使用前已被初始化</h2>
<ol>
<li>手动初始化内置型对象，比如 <code>int i = 0;</code></li>
<li>构造函数使用成员初值表进行初始化</li>
<li>为免除“跨编译单元初始化顺序不确定”问题，使用 local static 对象替换 static 对象</li>
</ol>
]]></content>
    </entry>
</feed>